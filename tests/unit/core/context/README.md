# Context 类测试驱动文档

# 1. 文档概述

## 1.1 文档目的

本文档为 `Context` 模块（上下文管理系统）的测试驱动规范，明确"需测试的功能范围、测试用例设计逻辑、执行标准及交付要求"，确保测试覆盖所有核心功能与接口契约，验证 Context 系统符合设计预期（如接口实现、消息管理、顺序验证、数据隔离等）。

## 1.2 测试对象

测试对象包括基于 `IContext` 抽象接口实现的 Context 系统，核心组件包括：

- `IContext` 接口：定义 Context 的抽象契约（数据获取、数据追加、数据清空）；
- `BaseContext` 类：提供 IContext 接口的基础实现，包含消息顺序验证、角色管理、数据隔离；

## 1.3 测试依据

- `IContext` 抽象接口定义的抽象方法契约；
- `BaseContext` 类的设计注释和消息验证逻辑；
- 消息角色定义（SYSTEM、USER、ASSISTANT、TOOL）；
- 消息顺序验证规则。

# 2. 测试目标

1. **接口合规性**：验证 IContext 接口的完整性和正确性，确保所有抽象方法被正确实现；
2. **功能有效性**：验证 Context 基础功能（初始化、数据管理、消息验证）正常可用；
3. **消息顺序验证**：验证消息添加时的顺序约束规则符合预期；
4. **消息拼接验证**：验证各种合法和非法的消息组合的正确处理；
5. **边界条件处理**：验证大量数据和异常情况下的正确处理。

## 2.1 消息顺序规则定义

根据 Context 模块设计，消息必须遵循以下顺序规则：

- **SYSTEM 消息**：只能在上下文开头，允许多个连续的系统消息
- **USER 消息**：可以接在任何消息后面，允许多个连续的用户消息
- **ASSISTANT 消息**：只能接在 SYSTEM 或 USER 消息后面，不允许连续的助手消息
- **TOOL 消息**：只能接在 ASSISTANT 消息后面，允许多个连续的工具消息

# 3. 测试范围

基于 Context 模块的核心能力，测试范围分为"接口测试模块"和"基础功能模块"两大类，具体测试项如下：

### 3.1 接口测试模块

|测试子项|测试内容说明|测试类型|
|---|---|---|
|接口抽象性验证|1. 验证 IContext 是抽象基类；2. 验证抽象方法定义；3. 验证接口文档完整性|接口测试|
|方法签名检查|1. 验证所有必需方法的存在和签名；2. 验证返回类型和参数类型；3. 验证方法可调用性|接口测试|
|接口实现验证|1. 验证 BaseContext 正确实现 IContext；2. 验证具体实现符合接口契约；3. 验证继承关系|接口测试|

### 3.2 基础功能模块

|测试子项|测试内容说明|测试类型|
|---|---|---|
|Context 初始化|1. 基础状态初始化（空上下文）；2. 继承关系验证；3. 初始状态检查|功能测试|
|上下文数据管理|1. get_context_data 数据获取；2. append_context_data 数据追加；3. clear_context_data 数据清空|功能测试|
|消息角色支持|1. SYSTEM 消息处理；2. USER 消息处理；3. ASSISTANT 消息处理；4. TOOL 消息处理|功能测试|
|消息顺序验证|1. 系统消息只能在开头；2. 连续系统消息允许；3. 连续用户消息允许；4. 连续工具消息允许；5. 助手消息禁止连续；6. 工具消息只能接助手；7. 助手消息只能接系统/用户|功能测试|
|消息拼接验证|1. 各种合法消息组合测试；2. 各种非法消息组合异常测试；3. 复杂对话流程验证|功能测试|
|边界条件处理|1. 大量数据处理能力；2. 空上下文操作；3. 异常输入处理|功能测试|

测试用例需遵循"正向验证+异常处理"原则，即既要验证合法操作正常执行，也要验证异常情况被正确处理。以下为关键测试用例模板（完整用例集可参考配套的测试文件）：

### 4.1 接口测试用例模板（以"接口抽象性验证"为例）

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|IFACE-CONTEXT-001|IContext 接口抽象性验证|1. Python 3.12+ 环境；2. 已导入 IContext 接口|1. 验证 IContext 是抽象基类（ABC）；2. 检查抽象方法集合；3. 验证方法名称和可调用性|1. IContext 是 ABC 的子类；2. 抽象方法集合包含三个必需方法；3. 所有方法可调用|高|

### 4.2 消息顺序验证用例模板

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|FUNC-ORDER-001|系统消息开头约束|1. 创建 BaseContext 实例；2. 准备系统消息和用户消息|1. 添加用户消息；2. 尝试添加系统消息；3. 验证异常抛出|1. 用户消息添加成功；2. 系统消息添加失败；3. 抛出"系统消息不能接在用户/助手/工具消息后面"异常|高|
|FUNC-ORDER-002|连续系统消息验证|1. 创建 BaseContext 实例；2. 准备多个系统消息|1. 添加第一个系统消息；2. 添加第二个系统消息；3. 验证成功|1. 两个系统消息都添加成功；2. 顺序保持正确|高|
|FUNC-ORDER-003|助手消息连续验证|1. 创建 BaseContext 实例；2. 准备用户消息和助手消息|1. 添加用户消息；2. 添加第一个助手消息；3. 尝试添加第二个助手消息；4. 验证异常|1. 用户和第一个助手消息添加成功；2. 第二个助手消息失败；3. 抛出"助手消息只能接在用户消息后面"异常|高|
|FUNC-ORDER-004|工具消息接助手验证|1. 创建 BaseContext 实例；2. 准备用户、助手、工具消息|1. 添加用户消息；2. 添加助手消息；3. 添加工具消息；4. 验证成功|1. 所有消息添加成功；2. 顺序为：用户→助手→工具|高|
|FUNC-ORDER-005|工具消息非助手验证|1. 创建 BaseContext 实例；2. 准备用户消息和工具消息|1. 添加用户消息；2. 尝试直接添加工具消息；3. 验证异常|1. 用户消息添加成功；2. 工具消息添加失败；3. 抛出"工具消息只能接在助手消息后面"异常|高|
|FUNC-ORDER-006|连续工具消息验证|1. 创建 BaseContext 实例；2. 准备用户、助手、工具消息|1. 添加用户→助手→工具消息；2. 添加第二个工具消息；3. 验证成功|1. 所有消息添加成功；2. 两个工具消息都添加成功|高|

### 4.3 消息拼接验证用例模板

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|FUNC-COMB-001|基础对话流程|1. 创建 BaseContext 实例；2. 准备基础对话消息|1. 添加：系统→用户→助手；2. 验证消息顺序和内容|1. 所有消息添加成功；2. 消息顺序正确|高|
|FUNC-COMB-002|工具调用流程|1. 创建 BaseContext 实例；2. 准备工具调用相关消息|1. 添加：系统→用户→助手→工具→工具；2. 验证流程|1. 所有消息添加成功；2. 支持多个工具结果|高|
|FUNC-COMB-003|多轮对话流程|1. 创建 BaseContext 实例；2. 准备多轮对话消息|1. 添加：系统→用户→助手→用户→助手；2. 验证多轮流程|1. 所有消息添加成功；2. 支持多轮对话|高|
|FUNC-COMB-004|复杂对话流程|1. 创建 BaseContext 实例；2. 准备复杂对话消息|1. 添加：系统→用户→助手→工具→用户→助手→工具→工具；2. 验证复杂流程|1. 所有消息添加成功；2. 复杂对话流程正常|高|
|FUNC-COMB-005|连续用户消息|1. 创建 BaseContext 实例；2. 准备多个用户消息|1. 添加：系统→用户→用户→用户；2. 验证连续用户消息|1. 所有消息添加成功；2. 连续用户消息被允许|高|
|FUNC-COMB-006|助手消息非法位置|1. 创建 BaseContext 实例；2. 准备助手和工具消息|1. 添加：系统→用户→助手→工具；2. 尝试在工具后添加助手；3. 验证异常|1. 前面消息添加成功；2. 工具后助手消息失败；3. 抛出正确异常|高|

## 5. 测试环境要求

### 5.1 硬件环境

- CPU：≥2核（支持数据处理和并发测试）
- 内存：≥4GB（支持大量上下文数据测试）
- 存储：≥5GB（测试数据和临时文件存储）

### 5.2 软件环境

|环境类型|具体要求|说明|
|---|---|---|
|操作系统|Linux（Ubuntu 20.04+/CentOS 7+）、macOS（12+）、Windows（WSL2）|支持跨平台测试|
|依赖工具|Python 3.12+、pytest 7.0+、pydantic 2.0+|通过 `uv pip install pytest pydantic` 安装|
|基础组件|uv（推荐）或 python3|用于环境管理和依赖安装|

### 5.3 静态检查要求

所有测试代码编辑完成后，必须执行以下静态检查流程：

#### 必需检查

1. **pyright 检查**：确保类型正确性和现代 Python 特性的正确使用

   ```bash
   uv run pyright tasking/core/context/
   ```

2. **pylint 检查**：确保代码风格、结构和最佳实践

   ```bash
   uv run pylint tasking/core/context/
   ```

#### 检查标准

- **pyright**：必须零错误，警告应评估并修复
- **pylint**：评分 ≥ 8.0/10，关键错误必须修复

#### 集成到开发流程

- 每次编辑代码后必须执行上述检查
- 提交前必须确保所有检查通过
- 测试脚本应集成静态检查功能

### 测试脚本集成

使用统一的测试脚本 `tests/run_tests.sh` 执行：

```bash
# 运行 Context 模块代码质量检查
./tests/run_tests.sh context quality

# 运行 Context 模块单元测试
./tests/run_tests.sh context unit

# 运行 Context 模块接口测试
./tests/run_tests.sh context interface

# 运行 Context 模块完整测试
./tests/run_tests.sh context all

# 生成测试覆盖率报告
./tests/run_tests.sh context coverage
```

## 6. 测试执行策略

### 6.1 执行顺序

1. **接口测试**：先验证 IContext 接口定义和契约正确，再进行实现测试
2. **基础功能测试**：验证 BaseContext 核心功能正常，再进行复杂场景测试
3. **消息顺序测试**：重点验证各种消息组合的顺序约束
4. **边界条件测试**：最后执行大量数据和异常情况测试

### 6.2 优先级与阻塞规则

- 优先级划分：接口测试（最高）> 基础功能模块（高）> 消息顺序验证（高）> 边界条件测试（中）
- 阻塞规则：若接口测试或基础功能模块测试失败，直接阻塞后续所有测试，需优先修复

### 6.3 缺陷管理

- **严重缺陷（P0）**：接口实现错误、消息数据丢失、顺序验证失效；需立即修复，修复后重新执行全量测试
- **一般缺陷（P1）**：异常处理不当；需在迭代内修复，修复后执行相关模块测试
- **轻微缺陷（P2）**：边界情况处理不完善、性能问题；可延后修复，不阻塞测试通过

# 7. 测试交付物

1. **测试用例集**：含完整测试用例的测试文件（`test_interface.py`、`test_base.py` 等，可通过 `run_tests.sh` 执行）
2. **测试报告**：含测试覆盖率（≥80%）、用例执行结果（通过率）、缺陷清单及修复情况
3. **问题记录**：未修复缺陷的跟踪表（含用例ID、复现步骤、影响范围）
4. **环境配置说明**：测试环境的详细部署步骤（用于回归测试）

### 7.1 交付物标准

- **测试覆盖率**: ≥ 80%
- **分支覆盖率**: ≥ 75%
- **关键测试用例**: 100% 通过
- **代码质量**: pyright 零错误，pylint ≥ 8.0/10

## 8. 附则

本文档需随 Context 模块的迭代同步更新：若新增 Context 实现（如带持久化的 Context）或修改接口定义（如新增抽象方法），需补充对应的测试范围、用例及执行标准。

### 8.1 测试设计原则

- **功能验证优先**：专注核心功能测试，不进行性能测试或并发测试
- **独立性**：每个测试方法独立运行，不依赖其他测试的执行顺序
- **可重复性**：使用固定的测试数据，确保测试结果的一致性
- **清晰性**：测试意图明确，易于理解和维护

### 8.2 测试隔离机制

- **环境隔离**：每个测试使用独立的测试环境
- **数据隔离**：测试数据不相互污染，使用独立的 Context 实例
- **状态隔离**：测试状态在测试间完全重置，使用 setUp/tearDown 清理

### 8.3 错误排查指南

**常见问题**:

1. **导入错误**: 确保使用正确的模块路径（如 `tasking.core.context`）
2. **依赖问题**: 使用虚拟环境隔离依赖
3. **消息角色错误**: 检查消息角色常量（如 `Role.USER`）
4. **顺序验证失败**: 理解消息添加的顺序约束规则
5. **路径问题**: 确保在项目根目录执行测试