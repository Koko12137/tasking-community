# Middleware 类测试驱动文档

# 1. 文档概述

## 1.1 文档目的

本文档为 `Middleware` 模块（中间件系统）的测试驱动规范，明确"需测试的功能范围、测试用例设计逻辑、执行标准及交付要求"，确保测试覆盖所有核心功能与中间件逻辑，验证中间件系统符合设计预期（如步骤计数、人类介入、记忆管理、钩子系统等）。

## 1.2 测试对象

测试对象为 Middleware 模块的各个中间件组件，核心组件包括：

- `IStepCounter` 接口：定义步骤计数器的抽象契约（限制管理、步骤计数、余额检查等）；
- `BaseStepCounter` 类：提供步骤计数器的基础实现；
- `MaxStepCounter` 类：基于最大步骤数的计数器实现；
- `TokenStepCounter` 类：基于 Token 成本的计数器实现；
- `IHumanClient` 接口：定义人类介入客户端的抽象契约；
- `BaseHumanClient` 类：提供人类介入客户端的基础实现；
- `IHumanInterfereHooks` 接口：定义人类介入钩子的抽象契约；
- `BaseHumanInterfereHooks` 类：提供人类介入钩子的基础实现；
- `IMemoryHooks` 接口：定义记忆中间件钩子的抽象契约；
- `StateMemoryHooks` 类：状态记忆钩子实现；
- `EpisodeMemoryHooks` 类：片段记忆钩子实现。

## 1.3 测试依据

- 各接口定义的抽象方法契约；
- 各实现类构造函数及核心方法的设计注释；
- 步骤计数器规范（限制管理、步骤计数、余额检查、充值重置）；
- 人类介入规范（上下文验证、消息交互、响应处理）；
- 人类介入请求格式规范（参考 `prompt/tool/human_interfere.md` 文档）；
- 记忆管理规范（记忆存储、检索、折叠、钩子执行、事件提取、记忆召回）。

# 2. 测试目标

1. **功能有效性**：验证中间件基础功能（步骤计数、人类介入、记忆管理）正常可用；
2. **接口合规性**：验证各接口的完整性和正确性，确保所有抽象方法被正确实现；
3. **计数逻辑**：验证步骤计数器的计数逻辑（限制检查、步骤累加、余额管理）符合预期；
4. **人类介入**：验证人类介入机制（上下文验证、消息交互、响应处理、钩子注入、approve 判断）正常工作；
5. **记忆管理**：验证记忆中间件的记忆管理（存储、检索、折叠、钩子执行、事件提取、记忆召回）符合预期；
6. **类型安全**：验证泛型类型约束和类型注解的正确使用。

# 3. 测试范围

基于 Middleware 模块的核心能力，测试范围分为"步骤计数器模块""人类介入模块""记忆管理模块"三大类，具体测试项如下：

## 3.1 步骤计数器模块

|测试子项|测试内容说明|测试类型|
|---|---|---|
|接口抽象性验证|1. 验证 IStepCounter 是抽象基类；2. 验证抽象方法定义；3. 验证接口文档完整性|接口测试|
|MaxStepCounter 功能|1. 最大步骤数限制管理；2. 步骤计数和累加；3. 限制检查和耗尽检测；4. 重置和充值功能|功能测试|
|TokenStepCounter 功能|1. Token 成本限制管理；2. Token 使用计数；3. 余额检查和耗尽检测；4. 重置和充值功能|功能测试|
|步骤计数器错误处理|1. 步骤耗尽异常处理；2. 限制超限处理；3. 无效参数处理；4. 并发访问安全|异常测试|

## 3.2 人类介入模块

|测试子项|测试内容说明|测试类型|
|---|---|---|
|接口抽象性验证|1. 验证 IHumanClient 是抽象基类；2. 验证抽象方法定义；3. 验证接口文档完整性|接口测试|
|BaseHumanClient 功能|1. 上下文验证（is_valid）；2. 消息交互（ask_human）；3. 响应处理（handle_human_response）；4. 人类介入异常处理|功能测试|
|人类介入钩子|1. 钩子接口定义验证；2. 钩子执行顺序；3. 钩子参数传递；4. 钩子错误处理；5. 人类介入请求格式验证（按 human_interfere.md 规范）；6. ask_human 调用验证；7. approve 响应判断和 HumanInterfere 异常抛出|功能测试|
|人类介入集成|1. 人类介入与 Agent 的集成；2. 人类介入与 Task 的集成；3. 完整人类介入流程；4. 复杂场景处理|集成测试|

## 3.3 记忆管理模块

|测试子项|测试内容说明|测试类型|
|---|---|---|
|接口抽象性验证|1. 验证 IMemoryHooks 是抽象基类；2. 验证抽象方法定义；3. 验证接口文档完整性|接口测试|
|StateMemoryHooks 功能|1. pre_run_once_hook：根据现有状态从数据库检索状态记忆并添加到任务上下文；2. post_run_once_hook：压缩当前任务上下文（事件提取）、存入数据库、清空任务上下文；3. 状态记忆事件提取功能验证；4. 状态记忆存储和检索功能验证|功能测试|
|EpisodeMemoryHooks 功能|1. pre_observe_hook：根据现有状态从向量数据库检索相关记忆并添加到任务上下文；2. post_run_once_hook：压缩当前任务上下文（事件提取）、存入数据库；3. 情节记忆事件提取功能验证；4. 情节记忆存储和检索功能验证|功能测试|
|MemoryFold 集成|1. 记忆管理与 Agent 的集成；2. 记忆管理与 Task 的集成；3. 完整记忆管理流程（pre_run_once_hook取回当前状态→pre_observe_hook根据当前状态检索相关记忆→任务执行→post_run_once_hook更新当前状态/提取情节记忆/存入数据库→清空上下文）；4. 复杂场景处理|集成测试|

测试用例需遵循"正向验证+异常处理"原则，即既要验证合法操作正常执行，也要验证异常情况被正确处理。以下为关键测试用例模板（完整用例集可参考配套的测试文件）：

## 4.1 步骤计数器用例模板（以"MaxStepCounter 初始化"为例）

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|STEP-INIT-001|MaxStepCounter 初始化|1. Python 3.12+ 环境；2. 已导入 MaxStepCounter|1. 使用限制参数创建 MaxStepCounter；2. 验证计数器ID生成；3. 验证限制和已用步骤|1. 计数器创建成功；2. 计数器ID唯一；3. 限制正确，已用步骤为0|高|

## 4.2 人类介入用例模板

### 4.2.1 上下文验证用例

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|HUMAN-VALID-001|上下文验证|1. 创建 BaseHumanClient 实例；2. 准备测试上下文|1. 调用 is_valid 方法；2. 传入有效上下文；3. 传入无效上下文；4. 验证返回结果|1. 有效上下文返回 True；2. 无效上下文返回 False；3. 异常情况正确处理|高|

### 4.2.2 人类介入钩子用例（以"钩子注入和 approve 判断"为例）

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|HUMAN-HOOK-001|钩子注入和人类介入请求|1. 创建 BaseHumanInterfereHooks 实例；2. 创建 MockHumanClient；3. 准备包含 `<human_interfere>` 标签的任务上下文|1. 模拟 hook 注入到 Agent；2. 调用 `on_post_human_interfere` 方法；3. 验证从任务上下文中提取 `<human_interfere>` 标签内容（按 human_interfere.md 格式）；4. 验证调用 `ask_human` 向人类客户端发起请求；5. 模拟人类客户端返回回复|1. 钩子正确执行；2. 正确提取 human_interfere 标签内容；3. ask_human 被正确调用；4. 人类回复被正确接收|最高|
|HUMAN-HOOK-002|approve 响应判断和异常抛出|1. 创建 BaseHumanInterfereHooks 实例（配置 approve_resp 集合）；2. 模拟人类客户端返回不同回复|1. 模拟人类返回空回复；2. 模拟人类返回在 approve_resp 中的回复；3. 模拟人类返回不在 approve_resp 中的回复；4. 验证异常抛出行为|1. 空回复时不抛出异常，继续执行；2. approve 回复时不抛出异常，继续执行；3. 非 approve 回复时抛出 HumanInterfere 异常；4. 异常包含正确的人类回复内容|最高|

## 4.3 记忆管理用例模板

### 4.3.1 状态记忆钩子用例

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|MEMORY-STATE-PRE-001|状态记忆 pre 钩子：记忆检索和上下文注入|1. 创建 StateMemoryHooks 实例；2. 准备 Mock 数据库（包含状态记忆）；3. 准备测试上下文和任务|1. 调用 pre_run_once_hook；2. 验证从数据库检索状态记忆（根据 user_id、project_id、trace_id、task_id 构建 key）；3. 验证检索到的记忆添加到任务上下文；4. 验证无记忆时的处理（直接返回）|1. 钩子正确执行；2. 数据库检索调用正确；3. 记忆正确添加到任务上下文；4. 无记忆时正常返回|高|
|MEMORY-STATE-POST-001|状态记忆 post 钩子：事件提取、存储和清空|1. 创建 StateMemoryHooks 实例；2. 准备包含任务上下文的任务；3. 准备 Mock 状态提取函数和数据库|1. 调用 post_run_once_hook；2. 验证压缩当前任务上下文（调用 state_extractor 进行事件提取）；3. 验证提取的状态记忆存入数据库；4. 验证任务上下文被清空|1. 钩子正确执行；2. 事件提取功能正常；3. 记忆正确存入数据库；4. 任务上下文正确清空|最高|
|MEMORY-STATE-EXTRACT-001|状态记忆事件提取功能|1. 创建 StateMemoryHooks 实例；2. 准备包含任务上下文的任务；3. 准备 Mock 状态提取函数|1. 调用 post_run_once_hook；2. 验证 state_extractor 被正确调用；3. 验证提取的内容格式正确（单个 TextBlock）；4. 验证提取失败时的错误处理|1. 事件提取函数正确调用；2. 提取内容格式正确；3. 提取失败时抛出正确异常|高|

### 4.3.2 情节记忆钩子用例

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|MEMORY-EPISODE-PRE-001|情节记忆 pre 钩子：记忆召回和上下文注入|1. 创建 EpisodeMemoryHooks 实例；2. 准备 Mock 向量数据库（包含情节记忆）；3. 准备测试上下文和任务|1. 调用 pre_observe_hook；2. 验证根据现有状态从向量数据库检索相关记忆（使用任务上下文构建查询，filter_expr 包含 task_id）；3. 验证检索到的记忆添加到任务上下文（格式化为记忆摘要）；4. 验证无记忆时的处理|1. 钩子正确执行；2. 向量数据库检索调用正确（query、top_k、threshold、filter_expr 参数正确）；3. 记忆正确添加到任务上下文；4. 无记忆时正常处理|高|
|MEMORY-EPISODE-POST-001|情节记忆 post 钩子：事件提取和存储|1. 创建 EpisodeMemoryHooks 实例；2. 准备包含任务上下文的任务；3. 准备 Mock 记忆压缩函数和向量数据库|1. 调用 post_run_once_hook；2. 验证压缩当前任务上下文（调用 memory_compressor 进行事件提取）；3. 验证提取的情节记忆存入向量数据库；4. 验证 episode_id 正确生成（基于现有记忆数量）|1. 钩子正确执行；2. 事件提取功能正常；3. 记忆正确存入向量数据库；4. episode_id 正确生成|最高|
|MEMORY-EPISODE-EXTRACT-001|情节记忆事件提取功能|1. 创建 EpisodeMemoryHooks 实例；2. 准备包含任务上下文的任务；3. 准备 Mock 记忆压缩函数|1. 调用 post_run_once_hook；2. 验证 memory_compressor 被正确调用；3. 验证压缩的内容格式正确（单个 TextBlock）；4. 验证压缩失败时的错误处理|1. 事件提取函数正确调用；2. 压缩内容格式正确；3. 压缩失败时抛出正确异常|高|

### 4.3.3 记忆折叠模块用例

|用例ID|测试项|前置条件|测试步骤|预期结果|优先级|
|---|---|---|---|---|---|
|MEMORY-FOLD-001|折叠模块事件提取功能|1. 创建 StateMemoryHooks 和 EpisodeMemoryHooks 实例；2. 准备包含现有记忆的任务上下文|1. 模拟 post_run_once_hook 执行；2. 验证折叠模块能正常对现有记忆进行事件提取；3. 验证提取的事件内容正确；4. 验证提取后记忆格式符合要求|1. 事件提取功能正常；2. 提取的事件内容正确；3. 提取后记忆格式符合要求|最高|
|MEMORY-FOLD-002|折叠模块记忆召回功能|1. 创建 StateMemoryHooks 和 EpisodeMemoryHooks 实例；2. 准备包含现有事件的数据库|1. 模拟 pre_run_once_hook 执行；2. 验证根据现有事件进行记忆召回；3. 验证召回的记忆相关性正确；4. 验证召回的记忆正确添加到任务上下文|1. 记忆召回功能正常；2. 召回的记忆相关性正确；3. 召回的记忆正确添加到任务上下文|最高|

# 5. 测试环境要求

## 5.1 硬件环境

- CPU：≥2核（支持异步测试和并发处理）；
- 内存：≥4GB（避免异步测试时内存不足）；
- 存储：≥5GB（测试数据和临时文件存储）。

## 5.2 软件环境

|环境类型|具体要求|说明|
|---|---|---|
|操作系统|Linux（Ubuntu 20.04+/CentOS 7+）、macOS（12+）、Windows（WSL2）|支持跨平台测试|
|依赖工具|Python 3.12+、pytest 7.0+、pytest-asyncio 0.21.0+|通过 `uv pip install pytest pytest-asyncio` 安装|
|基础组件|uv（推荐）或 python3|用于环境管理和依赖安装|

## 5.3 静态检查要求

所有测试代码编辑完成后，必须执行以下静态检查流程：

### 必需检查

1. **pyright 检查**：确保类型正确性和现代 Python 特性的正确使用

   ```bash
   uv run pyright tasking/core/middleware/
   ```

2. **pylint 检查**：确保代码风格、结构和最佳实践

   ```bash
   uv run pylint tasking/core/middleware/
   ```

### 检查标准

- **pyright**：必须零错误，警告应评估并修复
- **pylint**：评分 ≥ 8.0/10，关键错误必须修复

### 集成到开发流程

- 每次编辑代码后必须执行上述检查
- 提交前必须确保所有检查通过
- 测试脚本应集成静态检查功能（通过 `quality` 命令执行）

### 测试脚本集成

使用统一的测试脚本 `tests/run_tests.sh` 执行静态检查：

```bash
# 运行 Middleware 模块代码质量检查
./tests/run_tests.sh middleware quality

# 运行 Middleware 模块单元测试
./tests/run_tests.sh middleware unit

# 运行 Middleware 模块完整测试（质量检查 + 单元测试）
./tests/run_tests.sh middleware all
```

# 6. 测试执行策略

## 6.1 执行顺序

1. **接口测试**：先验证各接口定义和契约正确，再进行实现测试；
2. **步骤计数器测试**：验证步骤计数器的功能；
3. **人类介入测试**：验证人类介入机制的功能；
4. **记忆管理测试**：验证记忆中间件的功能；
5. **集成测试**：最后执行端到端集成测试。

## 6.2 优先级与阻塞规则

- 优先级划分：接口测试（最高）> 步骤计数器模块（高）> 人类介入模块（中）> 记忆管理模块（中）> 集成测试（中）；
- 阻塞规则：若接口测试或步骤计数器模块（如计数器初始化、限制检查）测试失败，直接阻塞后续所有测试，需优先修复。

## 6.3 缺陷管理

- **严重缺陷（P0）**：接口实现错误、计数器逻辑错误、人类介入失败；需立即修复，修复后重新执行全量测试；
- **一般缺陷（P1）**：记忆管理异常、钩子执行错误；需在迭代内修复，修复后执行相关模块测试；
- **轻微缺陷（P2）**：日志提示不清晰、非核心方法注释缺失；可延后修复，不阻塞测试通过。

# 7. 测试交付物

1. **测试用例集**：含完整测试用例的测试文件（`test_step_counter.py`、`test_human.py`、`test_middleware_memory.py` 等，可直接执行）；
2. **测试报告**：含测试覆盖率（≥80%）、用例执行结果（通过率）、缺陷清单及修复情况；
3. **问题记录**：未修复缺陷的跟踪表（含用例ID、复现步骤、影响范围）；
4. **环境配置说明**：测试环境的详细部署步骤（用于回归测试）。

# 8. 附则

本文档需随 Middleware 模块的迭代同步更新：若新增中间件实现（如新增特定中间件类型）或修改中间件逻辑（如新增钩子函数），需补充对应的测试范围、用例及执行标准。

