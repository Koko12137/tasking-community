"""
This type stub file was generated by pyright.
"""

import grpc
from typing import Dict, List, Optional, Union
from pymilvus.client.types import ResourceGroupConfig
from pymilvus.decorators import ignore_unimplemented, retry_on_rpc_failure
from pymilvus.orm.schema import Function
from . import utils
from .abstract import AnnSearchRequest, BaseRanker, FieldSchema
from .types import ReplicaInfo

class AsyncGrpcHandler:
    def __init__(self, uri: str = ..., host: str = ..., port: str = ..., channel: Optional[grpc.aio.Channel] = ..., **kwargs) -> None:
        ...
    
    def __enter__(self): # -> Self:
        ...
    
    def __exit__(self: object, exc_type: object, exc_val: object, exc_tb: object): # -> None:
        ...
    
    async def close(self): # -> None:
        ...
    
    @property
    def server_address(self): # -> str:
        ...
    
    def get_server_type(self): # -> Literal['zilliz', 'milvus']:
        ...
    
    async def ensure_channel_ready(self): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_collection(self, collection_name: str, fields: List, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def load_collection(self, collection_name: str, replica_number: Optional[int] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def wait_for_loading_collection(self, collection_name: str, timeout: Optional[float] = ..., is_refresh: bool = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def get_loading_progress(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., is_refresh: bool = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def describe_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> dict[Any, Any] | dict[str, Any]:
        ...
    
    @retry_on_rpc_failure()
    async def has_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> bool:
        ...
    
    @retry_on_rpc_failure()
    async def list_collections(self, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    @retry_on_rpc_failure()
    async def get_collection_stats(self, collection_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def get_partition_stats(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def get_load_state(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs): # -> LoadState:
        ...
    
    @retry_on_rpc_failure()
    async def refresh_load(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def get_server_version(self, timeout: Optional[float] = ..., **kwargs) -> str:
        ...
    
    @retry_on_rpc_failure()
    async def describe_replica(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[ReplicaInfo]:
        ...
    
    @retry_on_rpc_failure()
    async def rename_collection(self, old_name: str, new_name: str, new_db_name: str = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def update_schema(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> dict:
        ...
    
    @retry_on_rpc_failure()
    async def release_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def insert_rows(self, collection_name: str, entities: Union[Dict, List[Dict]], partition_name: Optional[str] = ..., schema: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def delete(self, collection_name: str, expression: str, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def upsert(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def upsert_rows(self, collection_name: str, entities: List, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> MutationResult:
        ...
    
    @retry_on_rpc_failure()
    async def search(self, collection_name: str, data: Union[List[List[float]], utils.SparseMatrixInputType], anns_field: str, param: Dict, limit: int, expression: Optional[str] = ..., partition_names: Optional[List[str]] = ..., output_fields: Optional[List[str]] = ..., round_decimal: int = ..., timeout: Optional[float] = ..., ranker: Optional[Function] = ..., **kwargs): # -> SearchResult:
        ...
    
    @retry_on_rpc_failure()
    async def hybrid_search(self, collection_name: str, reqs: List[AnnSearchRequest], rerank: Union[BaseRanker, Function], limit: int, partition_names: Optional[List[str]] = ..., output_fields: Optional[List[str]] = ..., round_decimal: int = ..., timeout: Optional[float] = ..., **kwargs): # -> SearchResult:
        ...
    
    @retry_on_rpc_failure()
    async def create_index(self, collection_name: str, field_name: str, params: Dict, timeout: Optional[float] = ..., **kwargs): # -> Status:
        ...
    
    @retry_on_rpc_failure()
    async def wait_for_creating_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> tuple[Literal[True], Any] | tuple[Literal[False], Any]:
        ...
    
    @retry_on_rpc_failure()
    async def get_index_state(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., timestamp: Optional[int] = ..., **kwargs): # -> tuple[Any, Any]:
        ...
    
    @retry_on_rpc_failure()
    async def drop_index(self, collection_name: str, field_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def load_partitions(self, collection_name: str, partition_names: List[str], replica_number: Optional[int] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def wait_for_loading_partitions(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ..., is_refresh: bool = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def release_partitions(self, collection_name: str, partition_names: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def has_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs) -> bool:
        ...
    
    @retry_on_rpc_failure()
    async def list_partitions(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    @retry_on_rpc_failure()
    async def get(self, collection_name: str, ids: List[int], output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def query(self, collection_name: str, expr: str, output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., strict_float32: bool = ..., **kwargs): # -> HybridExtraList:
        ...
    
    @retry_on_rpc_failure()
    @ignore_unimplemented(0)
    async def alloc_timestamp(self, timeout: Optional[float] = ..., **kwargs) -> int:
        ...
    
    @retry_on_rpc_failure()
    async def alter_collection_properties(self, collection_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_collection_properties(self, collection_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def alter_collection_field(self, collection_name: str, field_name: str, field_params: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def add_collection_field(self, collection_name: str, field_schema: FieldSchema, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def list_indexes(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    async def describe_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., timestamp: Optional[int] = ..., **kwargs): # -> dict[Any, Any] | None:
        ...
    
    @retry_on_rpc_failure()
    async def alter_index_properties(self, collection_name: str, index_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_index_properties(self, collection_name: str, index_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def alter_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def describe_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs): # -> dict[str, str]:
        ...
    
    @retry_on_rpc_failure()
    async def list_aliases(self, collection_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    def reset_db_name(self, db_name: str): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_database(self, db_name: str, properties: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_database(self, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def list_database(self, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    async def alter_database(self, db_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_database_properties(self, db_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def describe_database(self, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> Dict[str, Any]:
        ...
    
    @retry_on_rpc_failure()
    async def create_privilege_group(self, privilege_group: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_privilege_group(self, privilege_group: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def list_privilege_groups(self, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def add_privileges_to_group(self, privilege_group: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def remove_privileges_from_group(self, privilege_group: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_user(self, user: str, password: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_user(self, user: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def update_password(self, user: str, old_password: str, new_password: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def list_users(self, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def describe_user(self, username: str, include_role_info: bool, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def create_role(self, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_role(self, role_name: str, force_drop: bool = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def grant_role(self, username: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def revoke_role(self, username: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def describe_role(self, role_name: str, include_user_info: bool, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def list_roles(self, include_user_info: bool, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def select_grant_for_one_role(self, role_name: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> GrantInfo:
        ...
    
    @retry_on_rpc_failure()
    async def grant_privilege(self, role_name: str, object: str, object_name: str, privilege: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def revoke_privilege(self, role_name: str, object: str, object_name: str, privilege: str, db_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def grant_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def revoke_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def create_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def drop_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def update_resource_groups(self, configs: Dict[str, ResourceGroupConfig], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def describe_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def list_resource_groups(self, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    @retry_on_rpc_failure()
    async def transfer_replica(self, source: str, target: str, collection_name: str, num_replica: int, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @retry_on_rpc_failure()
    async def get_flush_state(self, segment_ids: List[int], collection_name: str, flush_ts: int, timeout: Optional[float] = ..., **kwargs) -> bool:
        """Get the flush state for given segments."""
        ...
    
    @retry_on_rpc_failure()
    async def flush(self, collection_names: List[str], timeout: Optional[float] = ..., **kwargs):
        ...
    
    @retry_on_rpc_failure()
    async def compact(self, collection_name: str, is_clustering: Optional[bool] = ..., is_l0: Optional[bool] = ..., timeout: Optional[float] = ..., **kwargs) -> int:
        ...
    
    @retry_on_rpc_failure()
    async def get_compaction_state(self, compaction_id: int, timeout: Optional[float] = ..., **kwargs): # -> CompactionState:
        ...
    
    @retry_on_rpc_failure()
    async def run_analyzer(self, texts: Union[str, List[str]], analyzer_params: Optional[Union[str, Dict]] = ..., with_hash: bool = ..., with_detail: bool = ..., collection_name: Optional[str] = ..., field_name: Optional[str] = ..., analyzer_names: Optional[Union[str, List[str]]] = ..., timeout: Optional[float] = ..., **kwargs): # -> AnalyzeResult | list[AnalyzeResult]:
        ...
    


