"""
This type stub file was generated by pyright.
"""

from typing import Dict, List, Optional, Union
from pymilvus.client.abstract import AnnSearchRequest, BaseRanker
from pymilvus.client.types import ResourceGroupConfig
from pymilvus.orm.collection import CollectionSchema
from pymilvus.orm.schema import FieldSchema
from pymilvus.orm.types import DataType
from .index import IndexParams

class AsyncMilvusClient:
    """AsyncMilvusClient is an EXPERIMENTAL class
    which only provides part of MilvusClient's methods"""
    def __init__(self, uri: str = ..., user: str = ..., password: str = ..., db_name: str = ..., token: str = ..., timeout: Optional[float] = ..., **kwargs) -> None:
        ...
    
    async def create_collection(self, collection_name: str, dimension: Optional[int] = ..., primary_field_name: str = ..., id_type: str = ..., vector_field_name: str = ..., metric_type: str = ..., auto_id: bool = ..., timeout: Optional[float] = ..., schema: Optional[CollectionSchema] = ..., index_params: Optional[IndexParams] = ..., **kwargs): # -> None:
        ...
    
    async def drop_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def rename_collection(self, old_name: str, new_name: str, target_db: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def load_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def release_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def create_index(self, collection_name: str, index_params: IndexParams, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def create_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def load_partitions(self, collection_name: str, partition_names: Union[str, List[str]], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def release_partitions(self, collection_name: str, partition_names: Union[str, List[str]], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def has_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs) -> bool:
        ...
    
    async def list_partitions(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    async def insert(self, collection_name: str, data: Union[Dict, List[Dict]], timeout: Optional[float] = ..., partition_name: Optional[str] = ..., **kwargs) -> Dict:
        ...
    
    async def upsert(self, collection_name: str, data: Union[Dict, List[Dict]], timeout: Optional[float] = ..., partition_name: Optional[str] = ..., **kwargs) -> Dict:
        """Upsert data into the collection asynchronously.

        Args:
            collection_name (str): Name of the collection to upsert into.
            data (List[Dict[str, any]]): A list of dicts to pass in. If list not provided, will
                cast to list.
            timeout (float, optional): The timeout to use, will override init timeout. Defaults
                to None.
            partition_name (str, optional): Name of the partition to upsert into.
            **kwargs (dict): Extra keyword arguments.

                * *partial_update* (bool, optional): Whether this is a partial update operation.
                    If True, only the specified fields will be updated while others remain unchanged
                    Default is False.

        Raises:
            DataNotMatchException: If the data has missing fields an exception will be thrown.
            MilvusException: General Milvus error on upsert.

        Returns:
            Dict: Number of rows that were upserted.
        """
        ...
    
    async def hybrid_search(self, collection_name: str, reqs: List[AnnSearchRequest], ranker: BaseRanker, limit: int = ..., output_fields: Optional[List[str]] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., **kwargs) -> List[List[dict]]:
        ...
    
    async def search(self, collection_name: str, data: Union[List[list], list], filter: str = ..., limit: int = ..., output_fields: Optional[List[str]] = ..., search_params: Optional[dict] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., anns_field: Optional[str] = ..., **kwargs) -> List[List[dict]]:
        ...
    
    async def query(self, collection_name: str, filter: str = ..., output_fields: Optional[List[str]] = ..., timeout: Optional[float] = ..., ids: Optional[Union[List, str, int]] = ..., partition_names: Optional[List[str]] = ..., **kwargs) -> List[dict]:
        ...
    
    async def get(self, collection_name: str, ids: Union[list, str, int], output_fields: Optional[List[str]] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., **kwargs) -> List[dict]:
        ...
    
    async def delete(self, collection_name: str, ids: Optional[Union[list, str, int]] = ..., timeout: Optional[float] = ..., filter: Optional[str] = ..., partition_name: Optional[str] = ..., **kwargs) -> Dict[str, int]:
        ...
    
    async def describe_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> dict:
        ...
    
    async def has_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> bool:
        ...
    
    async def list_collections(self, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    async def get_collection_stats(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    async def get_partition_stats(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    async def get_load_state(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs):
        ...
    
    async def refresh_load(self, collection_name: str, partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs):
        ...
    
    async def get_server_version(self, timeout: Optional[float] = ..., **kwargs) -> str:
        ...
    
    async def describe_replica(self, collection_name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    async def alter_collection_properties(self, collection_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_collection_properties(self, collection_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def alter_collection_field(self, collection_name: str, field_name: str, field_params: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def add_collection_field(self, collection_name: str, field_name: str, data_type: DataType, desc: str = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @classmethod
    def create_schema(cls, **kwargs): # -> CollectionSchema:
        ...
    
    @classmethod
    def create_field_schema(cls, name: str, data_type: DataType, desc: str = ..., **kwargs) -> FieldSchema:
        ...
    
    @classmethod
    def prepare_index_params(cls, field_name: str = ..., **kwargs) -> IndexParams:
        ...
    
    async def close(self): # -> None:
        ...
    
    async def list_indexes(self, collection_name: str, field_name: Optional[str] = ..., **kwargs): # -> list[Any]:
        ...
    
    async def describe_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    async def alter_index_properties(self, collection_name: str, index_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_index_properties(self, collection_name: str, index_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def create_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def alter_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def describe_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    async def list_aliases(self, collection_name: str = ..., timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    def using_database(self, db_name: str, **kwargs): # -> None:
        ...
    
    def use_database(self, db_name: str, **kwargs): # -> None:
        ...
    
    async def create_database(self, db_name: str, properties: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_database(self, db_name: str, **kwargs): # -> None:
        ...
    
    async def list_databases(self, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    async def describe_database(self, db_name: str, **kwargs) -> dict:
        ...
    
    async def alter_database_properties(self, db_name: str, properties: dict, **kwargs): # -> None:
        ...
    
    async def drop_database_properties(self, db_name: str, property_keys: List[str], **kwargs): # -> None:
        ...
    
    async def create_user(self, user_name: str, password: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_user(self, user_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def update_password(self, user_name: str, old_password: str, new_password: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def list_users(self, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    async def describe_user(self, user_name: str, timeout: Optional[float] = ..., **kwargs) -> dict:
        ...
    
    async def create_privilege_group(self, group_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_privilege_group(self, group_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def list_privilege_groups(self, timeout: Optional[float] = ..., **kwargs) -> List[Dict[str, Union[str, List[str]]]]:
        ...
    
    async def add_privileges_to_group(self, group_name: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def remove_privileges_from_group(self, group_name: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def create_role(self, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_role(self, role_name: str, force_drop: bool = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def grant_role(self, user_name: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def revoke_role(self, user_name: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def grant_privilege(self, role_name: str, object_type: str, privilege: str, object_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def revoke_privilege(self, role_name: str, object_type: str, privilege: str, object_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def grant_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def revoke_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def describe_role(self, role_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    async def list_roles(self, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    async def create_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def drop_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def update_resource_groups(self, configs: Dict[str, ResourceGroupConfig], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def describe_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs):
        ...
    
    async def list_resource_groups(self, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    async def transfer_replica(self, source: str, target: str, collection_name: str, num_replica: int, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def flush(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    async def compact(self, collection_name: str, is_clustering: Optional[bool] = ..., timeout: Optional[float] = ..., **kwargs) -> int:
        ...
    
    async def get_compaction_state(self, job_id: int, timeout: Optional[float] = ..., **kwargs) -> str:
        ...
    
    async def run_analyzer(self, texts: Union[str, List[str]], analyzer_params: Optional[Union[str, Dict]] = ..., with_hash: bool = ..., with_detail: bool = ..., collection_name: Optional[str] = ..., field_name: Optional[str] = ..., analyzer_names: Optional[Union[str, List[str]]] = ..., timeout: Optional[float] = ..., **kwargs):
        ...
    


