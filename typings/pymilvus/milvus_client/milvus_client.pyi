"""
This type stub file was generated by pyright.
"""

from typing import Dict, List, Optional, Union
from pymilvus.client.abstract import AnnSearchRequest, BaseRanker
from pymilvus.client.search_iterator import SearchIteratorV2
from pymilvus.client.types import CompactionPlans, LoadedSegmentInfo, ReplicaInfo, ResourceGroupConfig, SegmentInfo
from pymilvus.orm.collection import CollectionSchema, FieldSchema, Function, FunctionScore
from pymilvus.orm.iterator import SearchIterator
from pymilvus.orm.schema import StructFieldSchema
from pymilvus.orm.types import DataType
from .index import IndexParams

logger = ...
class MilvusClient:
    """The Milvus Client"""
    def __init__(self, uri: str = ..., user: str = ..., password: str = ..., db_name: str = ..., token: str = ..., timeout: Optional[float] = ..., **kwargs) -> None:
        """A client for the common Milvus use case.

        This client attempts to hide away the complexity of using Pymilvus. In a lot ofcases what
        the user wants is a simple wrapper that supports adding data, deleting data, and searching.

        Args:
            uri (str, optional): The connection address to use to connect to the
                instance. Defaults to "http://localhost:19530". Another example:
                "https://username:password@in01-12a.aws-us-west-2.vectordb.zillizcloud.com:19538
            timeout (float, optional): What timeout to use for function calls. Defaults
                to None.
                Unit: second
        """
        ...
    
    def create_collection(self, collection_name: str, dimension: Optional[int] = ..., primary_field_name: str = ..., id_type: str = ..., vector_field_name: str = ..., metric_type: str = ..., auto_id: bool = ..., timeout: Optional[float] = ..., schema: Optional[CollectionSchema] = ..., index_params: Optional[IndexParams] = ..., **kwargs): # -> None:
        ...
    
    def create_index(self, collection_name: str, index_params: IndexParams, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def insert(self, collection_name: str, data: Union[Dict, List[Dict]], timeout: Optional[float] = ..., partition_name: Optional[str] = ..., **kwargs) -> Dict:
        """Insert data into the collection.

        If the Milvus Client was initiated without an existing Collection, the first dict passed
        in will be used to initiate the collection.

        Args:
            data (List[Dict[str, any]]): A list of dicts to pass in. If list not provided, will
                cast to list.
            timeout (float, optional): The timeout to use, will override init timeout. Defaults
                to None.

        Raises:
            DataNotMatchException: If the data has missing fields an exception will be thrown.
            MilvusException: General Milvus error on insert.

        Returns:
            Dict: Number of rows that were inserted and the inserted primary key list.
        """
        ...
    
    def upsert(self, collection_name: str, data: Union[Dict, List[Dict]], timeout: Optional[float] = ..., partition_name: Optional[str] = ..., **kwargs) -> Dict:
        """Upsert data into the collection.

        Args:
            collection_name (str): Name of the collection to upsert into.
            data (List[Dict[str, any]]): A list of dicts to pass in. If list not provided, will
                cast to list.
            timeout (float, optional): The timeout to use, will override init timeout. Defaults
                to None.
            partition_name (str, optional): Name of the partition to upsert into.
            **kwargs (dict): Extra keyword arguments.

                * *partial_update* (bool, optional): Whether this is a partial update operation.
                    If True, only the specified fields will be updated while others remain unchanged
                    Default is False.

        Raises:
            DataNotMatchException: If the data has missing fields an exception will be thrown.
            MilvusException: General Milvus error on upsert.

        Returns:
            Dict: Number of rows that were upserted.
        """
        ...
    
    def hybrid_search(self, collection_name: str, reqs: List[AnnSearchRequest], ranker: Union[BaseRanker, Function], limit: int = ..., output_fields: Optional[List[str]] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., **kwargs) -> List[List[dict]]:
        """Conducts multi vector similarity search with a rerank for rearrangement.

        Args:
            collection_name(``string``): The name of collection.
            reqs (``List[AnnSearchRequest]``): The vector search requests.
            ranker (``Union[BaseRanker, Function]``): The ranker.
            limit (``int``): The max number of returned record, also known as `topk`.

            partition_names (``List[str]``, optional): The names of partitions to search on.
            output_fields (``List[str]``, optional):
                The name of fields to return in the search result.  Can only get scalar fields.
            round_decimal (``int``, optional):
                The specified number of decimal places of returned distance.
                Defaults to -1 means no round to returned distance.
            timeout (``float``, optional): A duration of time in seconds to allow for the RPC.
                If timeout is set to None, the client keeps waiting until the server
                responds or an error occurs.
            **kwargs (``dict``): Optional search params

                * *offset* (``int``, optinal)
                    offset for pagination.

                * *consistency_level* (``str/int``, optional)
                    Which consistency level to use when searching in the collection.

                    Options of consistency level: Strong, Bounded, Eventually, Session, Customized.

                    Note: this parameter overwrites the same one specified when creating collection,
                    if no consistency level was specified, search will use the
                    consistency level when you create the collection.

        Returns:
            List[List[dict]]: A nested list of dicts containing the result data.

        Raises:
            MilvusException: If anything goes wrong
        """
        ...
    
    def search(self, collection_name: str, data: Union[List[list], list], filter: str = ..., limit: int = ..., output_fields: Optional[List[str]] = ..., search_params: Optional[dict] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., anns_field: Optional[str] = ..., ranker: Optional[Union[Function, FunctionScore]] = ..., **kwargs) -> List[List[dict]]:
        """Search for a query vector/vectors.

        In order for the search to process, a collection needs to have been either provided
        at init or data needs to have been inserted.

        Args:
            data (Union[List[list], list, List[EmbeddingList]]): The vector/vectors/embedding
                list to search.
            limit (int, optional): How many results to return per search. Defaults to 10.
            filter(str, optional): A filter to use for the search. Defaults to None.
            output_fields (List[str], optional): List of which field values to return. If None
                specified, only primary fields including distances will be returned.
            search_params (dict, optional): The search params to use for the search.
            ranker (Function, optional): The ranker to use for the search.
            timeout (float, optional): Timeout to use, overides the client level assigned at init.
                Defaults to None.

        Raises:
            ValueError: The collection being searched doesnt exist. Need to insert data first.

        Returns:
            List[List[dict]]: A nested list of dicts containing the result data. Embeddings are
                not included in the result data.
        """
        ...
    
    def query(self, collection_name: str, filter: str = ..., output_fields: Optional[List[str]] = ..., timeout: Optional[float] = ..., ids: Optional[Union[List, str, int]] = ..., partition_names: Optional[List[str]] = ..., **kwargs) -> List[dict]:
        """Query for entries in the Collection.

        Args:
            filter (str): The filter to use for the query.
            output_fields (List[str], optional): List of which field values to return. If None
                specified, all fields excluding vector field will be returned.
            partitions (List[str], optional): Which partitions to perform query. Defaults to None.
            timeout (float, optional): Timeout to use, overides the client level assigned at init.
                Defaults to None.

        Raises:
            ValueError: Missing collection.

        Returns:
            List[dict]: A list of result dicts, vectors are not included.
        """
        ...
    
    def query_iterator(self, collection_name: str, batch_size: Optional[int] = ..., limit: Optional[int] = ..., filter: Optional[str] = ..., output_fields: Optional[List[str]] = ..., partition_names: Optional[List[str]] = ..., timeout: Optional[float] = ..., **kwargs): # -> QueryIterator:
        ...
    
    def search_iterator(self, collection_name: str, data: Union[List[list], list], batch_size: Optional[int] = ..., filter: Optional[str] = ..., limit: Optional[int] = ..., output_fields: Optional[List[str]] = ..., search_params: Optional[dict] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., anns_field: Optional[str] = ..., round_decimal: int = ..., **kwargs) -> Union[SearchIteratorV2, SearchIterator]:
        """Creates an iterator for searching vectors in batches.

        This method returns an iterator that performs vector similarity search in batches,
        which is useful when dealing with large result sets. It automatically attempts to use
        Search Iterator V2 if supported by the server, otherwise falls back to V1.

        Args:
            collection_name (str): Name of the collection to search in.
            data (Union[List[list], list]): Vector data to search with. For V2, only single vector
                search is supported.
            batch_size (int, optional): Number of results to fetch per batch. Defaults to 1000.
                Must be between 1 and MAX_BATCH_SIZE.
            filter (str, optional): Filtering expression to filter the results. Defaults to None.
            limit (int, optional): Total number of results to return. Defaults to UNLIMITED.
                (Deprecated) This parameter is deprecated and will be removed in a future release.
            output_fields (List[str], optional): Fields to return in the results.
            search_params (dict, optional): Parameters for the search operation.
            timeout (float, optional): Timeout in seconds for each RPC call.
            partition_names (List[str], optional): Names of partitions to search in.
            anns_field (str, optional): Name of the vector field to search. Can be empty when
                there is only one vector field in the collection.
            round_decimal (int, optional): Number of decimal places for distance values.
                Defaults to -1 (no rounding).
            **kwargs: Additional arguments to pass to the search operation.

        Returns:
            SearchIterator: An iterator object that yields search results in batches.

        Raises:
            MilvusException: If the search operation fails.
            ParamError: If the input parameters are invalid (e.g., invalid batch_size or multiple
                vectors in data when using V2).

        Examples:
            >>> # Search with iterator
            >>> iterator = client.search_iterator(
            ...     collection_name="my_collection",
            ...     data=[[0.1, 0.2]],
            ...     batch_size=100
            ... )
        """
        ...
    
    def get(self, collection_name: str, ids: Union[list, str, int], output_fields: Optional[List[str]] = ..., timeout: Optional[float] = ..., partition_names: Optional[List[str]] = ..., **kwargs) -> List[dict]:
        """Grab the inserted vectors using the primary key from the Collection.

        Due to current implementations, grabbing a large amount of vectors is slow.

        Args:
            ids (str): The pk's to get vectors for. Depending on pk_field type it can be int or str
            or a list of either.
            timeout (float, optional): Timeout to use, overides the client level assigned at
                init. Defaults to None.

        Raises:
            ValueError: Missing collection.

        Returns:
            List[dict]: A list of result dicts with keys {pk_field, vector_field}
        """
        ...
    
    def delete(self, collection_name: str, ids: Optional[Union[list, str, int]] = ..., timeout: Optional[float] = ..., filter: Optional[str] = ..., partition_name: Optional[str] = ..., **kwargs) -> Dict[str, int]:
        """Delete entries in the collection by their pk or by filter.

        Starting from version 2.3.2, Milvus no longer includes the primary keys in the result
        when processing the delete operation on expressions.
        This change is due to the large amount of data involved.
        The delete interface no longer returns any results.
        If no exceptions are thrown, it indicates a successful deletion.
        However, for backward compatibility, If the primary_keys returned from old
        Milvus(previous 2.3.2) is not empty, the list of primary keys is still returned.

        Args:
            ids (list, str, int, optional): The pk's to delete.
                Depending on pk_field type it can be int or str or a list of either.
                Default to None.
            filter(str, optional): A filter to use for the deletion. Defaults to none.
            timeout (int, optional): Timeout to use, overides the client level assigned at init.
                Defaults to None.

            Note: You need to passin either ids or filter, and they cannot be used at the same time.

        Returns:
            Dict: with key 'deleted_count' and value number of rows that were deleted.
        """
        ...
    
    def get_collection_stats(self, collection_name: str, timeout: Optional[float] = ...) -> Dict:
        ...
    
    def describe_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        ...
    
    def has_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        ...
    
    def list_collections(self, **kwargs): # -> CoroutineType[Any, Any, Any]:
        ...
    
    def drop_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        """Delete the collection stored in this object"""
        ...
    
    def rename_collection(self, old_name: str, new_name: str, target_db: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    @classmethod
    def create_schema(cls, **kwargs): # -> CollectionSchema:
        ...
    
    @classmethod
    def create_struct_field_schema(cls) -> StructFieldSchema:
        ...
    
    @classmethod
    def create_field_schema(cls, name: str, data_type: DataType, desc: str = ..., **kwargs) -> FieldSchema:
        """Create a field schema. Wrapping orm.FieldSchema.

        Args:
            name (str): The name of the field.
            dtype (DataType): The data type of the field.
            desc (str): The description of the field.
            **kwargs: Additional keyword arguments.

        Returns:
            FieldSchema: the FieldSchema created.
        """
        ...
    
    @classmethod
    def prepare_index_params(cls, field_name: str = ..., **kwargs) -> IndexParams:
        ...
    
    def close(self): # -> None:
        ...
    
    def load_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        """Loads the collection."""
        ...
    
    def release_collection(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def get_load_state(self, collection_name: str, partition_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    def refresh_load(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def list_indexes(self, collection_name: str, field_name: Optional[str] = ..., **kwargs): # -> list[Any]:
        """List all indexes of collection. If `field_name` is not specified,
            return all the indexes of this collection, otherwise this interface will return
            all indexes on this field of the collection.

        :param collection_name: The name of collection.
        :type  collection_name: str

        :param field_name: The name of field.  If no field name is specified, all indexes
                of this collection will be returned.

        :return: The name list of all indexes.
        :rtype: str list
        """
        ...
    
    def drop_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def describe_index(self, collection_name: str, index_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    def alter_index_properties(self, collection_name: str, index_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def drop_index_properties(self, collection_name: str, index_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def alter_collection_properties(self, collection_name: str, properties: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def drop_collection_properties(self, collection_name: str, property_keys: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def alter_collection_field(self, collection_name: str, field_name: str, field_params: dict, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def add_collection_field(self, collection_name: str, field_name: str, data_type: DataType, desc: str = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        """Add a new field to the collection.

        Args:
            collection_name(``string``): The name of collection.
            name (str): The name of the field.
            dtype (DataType): The data type of the field.
            desc (str): The description of the field.
            timeout (``float``, optional): A duration of time in seconds to allow for the RPC.
                If timeout is set to None, the client keeps waiting until the server
                responds or an error occurs.
            **kwargs (``dict``): Optional field params
                nullable: bool, indicates field is nullable or not, shall be ``True`` for now
                default_value: default val for added field

        Raises:
            MilvusException: If anything goes wrong
        """
        ...
    
    def create_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def drop_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def has_partition(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs) -> bool:
        ...
    
    def list_partitions(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    def load_partitions(self, collection_name: str, partition_names: Union[str, List[str]], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def release_partitions(self, collection_name: str, partition_names: Union[str, List[str]], timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def get_partition_stats(self, collection_name: str, partition_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    def create_user(self, user_name: str, password: str, timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        ...
    
    def drop_user(self, user_name: str, timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        ...
    
    def update_password(self, user_name: str, old_password: str, new_password: str, reset_connection: Optional[bool] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def list_users(self, timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        ...
    
    def describe_user(self, user_name: str, timeout: Optional[float] = ..., **kwargs): # -> dict[str, Any] | dict[Any, Any]:
        ...
    
    def grant_role(self, user_name: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def revoke_role(self, user_name: str, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def create_role(self, role_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def drop_role(self, role_name: str, force_drop: bool = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def describe_role(self, role_name: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    def list_roles(self, timeout: Optional[float] = ..., **kwargs): # -> list[Any]:
        ...
    
    def grant_privilege(self, role_name: str, object_type: str, privilege: str, object_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def revoke_privilege(self, role_name: str, object_type: str, privilege: str, object_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def grant_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        """Grant a privilege or a privilege group to a role.

        Args:
            role_name (``str``): The name of the role.
            privilege (``str``): The privilege or privilege group to grant.
            collection_name (``str``): The name of the collection.
            db_name (``str``, optional): The name of the database. It will use default database
                if not specified.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def revoke_privilege_v2(self, role_name: str, privilege: str, collection_name: str, db_name: Optional[str] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        """Revoke a privilege or a privilege group from a role.

        Args:
            role_name (``str``): The name of the role.
            privilege (``str``): The privilege or privilege group to revoke.
            collection_name (``str``): The name of the collection.
            db_name (``str``, optional): The name of the database. It will use default database
                if not specified.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def create_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def drop_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def alter_alias(self, collection_name: str, alias: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def describe_alias(self, alias: str, timeout: Optional[float] = ..., **kwargs) -> Dict:
        ...
    
    def list_aliases(self, collection_name: str = ..., timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    def using_database(self, db_name: str, **kwargs): # -> None:
        ...
    
    def use_database(self, db_name: str, **kwargs): # -> None:
        ...
    
    def create_database(self, db_name: str, properties: Optional[dict] = ..., timeout: Optional[float] = ..., **kwargs): # -> None:
        ...
    
    def drop_database(self, db_name: str, **kwargs): # -> None:
        ...
    
    def list_databases(self, timeout: Optional[float] = ..., **kwargs) -> List[str]:
        ...
    
    def describe_database(self, db_name: str, **kwargs) -> dict:
        ...
    
    def alter_database_properties(self, db_name: str, properties: dict, **kwargs): # -> None:
        ...
    
    def drop_database_properties(self, db_name: str, property_keys: List[str], **kwargs): # -> None:
        ...
    
    def flush(self, collection_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        """Seal all segments in the collection. Inserts after flushing will be written into
            new segments.

        Args:
            collection_name(``string``): The name of collection.
            timeout (float): an optional duration of time in seconds to allow for the RPCs.
                If timeout is not set, the client keeps waiting until the server
                responds or an error occurs.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def compact(self, collection_name: str, is_clustering: Optional[bool] = ..., is_l0: Optional[bool] = ..., timeout: Optional[float] = ..., **kwargs) -> int:
        """Compact merge the small segments in a collection

        Args:
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

            is_clustering (``bool``, optional): Option to trigger clustering compaction.

        Raises:
            MilvusException: If anything goes wrong.

        Returns:
            int: An integer represents the server's compaction job. You can use this job ID
            for subsequent state inquiries.
        """
        ...
    
    def get_compaction_state(self, job_id: int, timeout: Optional[float] = ..., **kwargs) -> str:
        """Get the state of compaction job

        Args:
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.

        Returns:
            str: the state of this compaction job. Possible values are "UndefiedState", "Executing"
            and "Completed".
        """
        ...
    
    def get_server_version(self, timeout: Optional[float] = ..., **kwargs) -> str:
        """Get the running server's version

        Args:
            timeout (``float``, optional): A duration of time in seconds to allow for the RPC.
                If timeout is set to None, the client keeps waiting until the server
                responds or an error occurs.

        Returns:
            str: A string represent the server's version.

        Raises:
            MilvusException: If anything goes wrong
        """
        ...
    
    def create_privilege_group(self, group_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        """Create a new privilege group.

        Args:
            group_name (``str``): The name of the privilege group.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def drop_privilege_group(self, group_name: str, timeout: Optional[float] = ..., **kwargs): # -> None:
        """Drop a privilege group.

        Args:
            group_name (``str``): The name of the privilege group.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def list_privilege_groups(self, timeout: Optional[float] = ..., **kwargs) -> List[Dict[str, str]]:
        """List all privilege groups.

        Args:
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Returns:
            List[Dict[str, str]]: A list of privilege groups.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def add_privileges_to_group(self, group_name: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        """Add privileges to a privilege group.

        Args:
            group_name (``str``): The name of the privilege group.
            privileges (``List[str]``): A list of privileges to be added to the group.
                Privileges should be the same type in a group otherwise it will raise an exception.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def remove_privileges_from_group(self, group_name: str, privileges: List[str], timeout: Optional[float] = ..., **kwargs): # -> None:
        """Remove privileges from a privilege group.

        Args:
            group_name (``str``): The name of the privilege group.
            privileges (``List[str]``): A list of privileges to be removed from the group.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def create_resource_group(self, name: str, timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        """Create a resource group
            It will success whether or not the resource group exists.

        Args:
            name: The name of the resource group.
        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def update_resource_groups(self, configs: Dict[str, ResourceGroupConfig], timeout: Optional[float] = ...): # -> CoroutineType[Any, Any, Any]:
        """Update resource groups.
            This function updates the resource groups based on the provided configurations.

        Args:
            configs: A mapping of resource group names to their configurations.
            timeout: The timeout value in seconds. Defaults to None.
        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def drop_resource_group(self, name: str, timeout: Optional[float] = ...): # -> CoroutineType[Any, Any, Any]:
        """Drop a resource group
            It will success if the resource group is existed and empty, otherwise fail.

        Args:
            name: The name of the resource group.
            timeout: The timeout value in seconds. Defaults to None.
        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def describe_resource_group(self, name: str, timeout: Optional[float] = ...): # -> CoroutineType[Any, Any, Any]:
        """Drop a resource group
            It will success if the resource group is existed and empty, otherwise fail.

        Args:
            name: The name of the resource group.
            timeout: The timeout value in seconds. Defaults to None.
        Returns:
            ResourceGroupInfo: The detail info of the resource group.
        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def list_resource_groups(self, timeout: Optional[float] = ...): # -> CoroutineType[Any, Any, Any]:
        """list all resource group names

        Args:
            timeout: The timeout value in seconds. Defaults to None.
        Returns:
            list[str]: all resource group names
        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def transfer_replica(self, source_group: str, target_group: str, collection_name: str, num_replicas: int, timeout: Optional[float] = ...): # -> CoroutineType[Any, Any, Any]:
        """transfer num_replica from source resource group to target resource group

        Args:
            source_group: source resource group name
            target_group: target resource group name
            collection_name: collection name which replica belong to
            num_replicas: transfer replica num
            timeout: The timeout value in seconds. Defaults to None.

        Raises:
            MilvusException: If anything goes wrong.
        """
        ...
    
    def describe_replica(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[ReplicaInfo]:
        """Get the current loaded replica information

        Args:
            collection_name (``str``): The name of the given collection.
            timeout (``float``, optional): An optional duration of time in seconds to allow
                for the RPC. When timeout is set to None, client waits until server response
                or error occur.
        Returns:
            List[ReplicaInfo]: All the replica information.
        """
        ...
    
    def run_analyzer(self, texts: Union[str, List[str]], analyzer_params: Optional[Union[str, Dict]] = ..., with_hash: bool = ..., with_detail: bool = ..., collection_name: Optional[str] = ..., field_name: Optional[str] = ..., analyzer_names: Optional[Union[str, List[str]]] = ..., timeout: Optional[float] = ...): # -> CoroutineType[Any, Any, Any]:
        """Run analyzer. Return result tokens of analysis.
        Args:
            text(``str``,``List[str]``): The input text (string or string list).
            analyzer_params(``str``,``Dict``,``None``): The parameters of analyzer.
            timeout(``float``, optional): The timeout value in seconds. Defaults to None.
        Returns:
                (``List[str]``,``List[List[str]]``): The result tokens of analysis.
        """
        ...
    
    def update_replicate_configuration(self, clusters: Optional[List[Dict]] = ..., cross_cluster_topology: Optional[List[Dict]] = ..., timeout: Optional[float] = ..., **kwargs): # -> CoroutineType[Any, Any, Any]:
        """
        Update replication configuration across Milvus clusters.

        Args:
            clusters (List[Dict], optional): List of cluster configurations.
            Each dict should contain:
                - cluster_id (str): Unique identifier for the cluster
                - connection_param (Dict): Connection parameters with 'uri' and 'token'
                - pchannels (List[str], optional): Physical channels for the cluster

            cross_cluster_topology (List[Dict], optional): List of replication relationships.
            Each dict should contain:
                - source_cluster_id (str): ID of the source cluster
                - target_cluster_id (str): ID of the target cluster

            cross_cluster_topology (List[Dict], optional): List of replication relationships.
            Each dict should contain:
                - source_cluster_id (str): ID of the source cluster
                - target_cluster_id (str): ID of the target cluster

            timeout (float, optional): An optional duration of time in seconds to allow for the RPC
            **kwargs: Additional arguments

        Returns:
            Status: The status of the operation

        Raises:
            ParamError: If neither clusters nor cross_cluster_topology is provided
            MilvusException: If the operation fails

        Examples:
            client.update_replicate_configuration(
                clusters=[
                    {
                        "cluster_id": "source_cluster",
                        "connection_param": {
                            "uri": "http://source:19530",
                            "token": "source_token"
                        },
                        "pchannels": ["source_pchannel1", "source_pchannel2"]
                    },
                    {
                        "cluster_id": "target_cluster",
                        "connection_param": {
                            "uri": "http://target:19530",
                            "token": "target_token"
                        },
                        "pchannels": ["target_pchannel1", "target_pchannel2"]
                    }
                ],
                cross_cluster_topology=[
                    {
                        "source_cluster_id": "source_cluster",
                        "target_cluster_id": "target_cluster"
                    }
                ]
            )
        """
        ...
    
    def flush_all(self, timeout: Optional[float] = ..., **kwargs) -> None:
        """Flush all collections.

        Args:
            timeout (Optional[float]): An optional duration of time in seconds to allow for the RPC.
            **kwargs: Additional arguments.
        """
        ...
    
    def get_flush_all_state(self, timeout: Optional[float] = ..., **kwargs) -> bool:
        """Get the flush all state.

        Args:
            timeout (Optional[float]): An optional duration of time in seconds to allow for the RPC.
            **kwargs: Additional arguments.

        Returns:
            bool: True if flush all operation is completed, False otherwise.
        """
        ...
    
    def list_loaded_segments(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[LoadedSegmentInfo]:
        """List loaded segments for a collection.

        Args:
            collection_name (str): The name of the collection.
            timeout (Optional[float]): An optional duration of time in seconds to allow for the RPC.
            **kwargs: Additional arguments.

        Returns:
            List[LoadedSegmentInfo]: A list of loaded segment information.
        """
        ...
    
    def list_persistent_segments(self, collection_name: str, timeout: Optional[float] = ..., **kwargs) -> List[SegmentInfo]:
        """List persistent segments for a collection.

        Args:
            collection_name (str): The name of the collection.
            timeout (Optional[float]): An optional duration of time in seconds to allow for the RPC.
            **kwargs: Additional arguments.

        Returns:
            List[SegmentInfo]: A list of persistent segment information.
        """
        ...
    
    def get_server_type(self): # -> Literal['zilliz', 'milvus']:
        """Get the server type.

        Returns:
            str: The server type (e.g., "milvus", "zilliz").
        """
        ...
    
    def get_compaction_plans(self, job_id: int, timeout: Optional[float] = ..., **kwargs) -> CompactionPlans:
        """Get compaction plans for a specific job.

        Args:
            job_id (int): The ID of the compaction job.
            timeout (Optional[float]): An optional duration of time in seconds to allow for the RPC.
            **kwargs: Additional arguments.

        Returns:
            CompactionPlans: The compaction plans for the specified job.
        """
        ...
    


