"""
This type stub file was generated by pyright.
"""

import os
import logging
import datetime
import httpx
from typing import Any, AsyncIterator, Callable, Generic, Iterator, TYPE_CHECKING, TypeVar, overload
from typing_extensions import Awaitable, ParamSpec, override
from ._streaming import AsyncStream, Stream
from ._request_options import RequestOptions
from ._base_client import BaseClient

if TYPE_CHECKING:
    ...
P = ParamSpec("P")
R = TypeVar("R")
_T = TypeVar("_T")
log: logging.Logger = ...
class LegacyAPIResponse(Generic[R]):
    """This is a legacy class as it will be replaced by `APIResponse`
    and `AsyncAPIResponse` in the `_response.py` file in the next major
    release.

    For the sync client this will mostly be the same with the exception
    of `content` & `text` will be methods instead of properties. In the
    async client, all methods will be async.

    A migration script will be provided & the migration in general should
    be smooth.
    """
    _cast_to: type[R]
    _client: BaseClient[Any, Any]
    _parsed_by_type: dict[type[Any], Any]
    _stream: bool
    _stream_cls: type[Stream[Any]] | type[AsyncStream[Any]] | None
    _options: RequestOptions
    http_response: httpx.Response
    retries_taken: int
    def __init__(self, *, raw: httpx.Response, cast_to: type[R], client: BaseClient[Any, Any], stream: bool, stream_cls: type[Stream[Any]] | type[AsyncStream[Any]] | None, options: RequestOptions, retries_taken: int = ...) -> None:
        ...
    
    @property
    def request_id(self) -> str | None:
        ...
    
    @overload
    def parse(self, *, to: type[_T]) -> _T:
        ...
    
    @overload
    def parse(self) -> R:
        ...
    
    def parse(self, *, to: type[_T] | None = ...) -> R | _T:
        ...
    
    @property
    def headers(self) -> httpx.Headers:
        ...
    
    @property
    def http_request(self) -> httpx.Request:
        ...
    
    @property
    def status_code(self) -> int:
        ...
    
    @property
    def url(self) -> httpx.URL:
        ...
    
    @property
    def method(self) -> str:
        ...
    
    @property
    def content(self) -> bytes:
        """Return the binary response content.

        NOTE: this will be removed in favour of `.read()` in the
        next major version.
        """
        ...
    
    @property
    def text(self) -> str:
        """Return the decoded response content.

        NOTE: this will be turned into a method in the next major version.
        """
        ...
    
    @property
    def http_version(self) -> str:
        ...
    
    @property
    def is_closed(self) -> bool:
        ...
    
    @property
    def elapsed(self) -> datetime.timedelta:
        """The time taken for the complete request/response cycle to complete."""
        ...
    
    @override
    def __repr__(self) -> str:
        ...
    


class MissingStreamClassError(TypeError):
    def __init__(self) -> None:
        ...
    


def to_raw_response_wrapper(func: Callable[P, R]) -> Callable[P, LegacyAPIResponse[R]]:
    """Higher order function that takes one of our bound API methods and wraps it
    to support returning the raw `APIResponse` object directly.
    """
    ...

def async_to_raw_response_wrapper(func: Callable[P, Awaitable[R]]) -> Callable[P, Awaitable[LegacyAPIResponse[R]]]:
    """Higher order function that takes one of our bound API methods and wraps it
    to support returning the raw `APIResponse` object directly.
    """
    ...

class HttpxBinaryResponseContent:
    response: httpx.Response
    def __init__(self, response: httpx.Response) -> None:
        ...
    
    @property
    def content(self) -> bytes:
        ...
    
    @property
    def text(self) -> str:
        ...
    
    @property
    def encoding(self) -> str | None:
        ...
    
    @property
    def charset_encoding(self) -> str | None:
        ...
    
    def json(self, **kwargs: Any) -> Any:
        ...
    
    def read(self) -> bytes:
        ...
    
    def iter_bytes(self, chunk_size: int | None = ...) -> Iterator[bytes]:
        ...
    
    def iter_text(self, chunk_size: int | None = ...) -> Iterator[str]:
        ...
    
    def iter_lines(self) -> Iterator[str]:
        ...
    
    def iter_raw(self, chunk_size: int | None = ...) -> Iterator[bytes]:
        ...
    
    def write_to_file(self, file: str | os.PathLike[str]) -> None:
        """Write the output to the given file.

        Accepts a filename or any path-like object, e.g. pathlib.Path

        Note: if you want to stream the data to the file instead of writing
        all at once then you should use `.with_streaming_response` when making
        the API request, e.g. `client.with_streaming_response.foo().stream_to_file('my_filename.txt')`
        """
        ...
    
    def close(self) -> None:
        ...
    
    async def aread(self) -> bytes:
        ...
    
    async def aiter_bytes(self, chunk_size: int | None = ...) -> AsyncIterator[bytes]:
        ...
    
    async def aiter_text(self, chunk_size: int | None = ...) -> AsyncIterator[str]:
        ...
    
    async def aiter_lines(self) -> AsyncIterator[str]:
        ...
    
    async def aiter_raw(self, chunk_size: int | None = ...) -> AsyncIterator[bytes]:
        ...
    
    async def aclose(self) -> None:
        ...
    


