"""
This type stub file was generated by pyright.
"""

import json
import logging
import httpx
from types import TracebackType
from typing import Any, AsyncIterator, Dict, Generator, Generic, Iterator, Optional, TYPE_CHECKING, Type, TypeVar, Union
from typing_extensions import override
from httpx import Limits, Timeout, URL
from httpx._types import RequestFiles
from ._qs import Querystring
from ._models import GenericModel
from ._request_options import ExtraRequestOptions, RequestOptions
from ._streaming import AsyncStream, Stream
from ._types import Body, NotGiven, PostParser, Query, ResponseT

SyncPageT = TypeVar("SyncPageT", bound="BaseSyncPage[Any]")
AsyncPageT = TypeVar("AsyncPageT", bound="BaseAsyncPage[Any]")
_T = TypeVar("_T")
_T_co = TypeVar("_T_co", covariant=True)
_StreamT = TypeVar("_StreamT", bound=Stream[Any])
_AsyncStreamT = TypeVar("_AsyncStreamT", bound=AsyncStream[Any])
log: logging.Logger = ...
class _DefaultHttpxClient(httpx.Client):
    def __init__(self, **kwargs: Any) -> None:
        ...
    


if TYPE_CHECKING:
    DefaultHttpxClient = httpx.Client
else:
    ...
class SyncHttpxClientWrapper(DefaultHttpxClient):
    def __del__(self) -> None:
        ...
    


def make_request_options(*, query: Dict[str, Any] | None = ..., extra_headers: Dict[str, str] | None = ..., extra_query: Dict[str, Any] | None = ..., extra_body: Dict[str, Any] | None = ..., timeout: float | httpx.Timeout | None = ..., post_parser: PostParser | NotGiven = ...) -> ExtraRequestOptions:
    ...

_HttpxClientT = TypeVar("_HttpxClientT", bound=Union[httpx.Client, httpx.AsyncClient])
class BaseClient(Generic[_HttpxClientT]):
    _client: _HttpxClientT
    _base_url: URL
    max_retries: int
    timeout: Union[float, Timeout, None]
    _limits: Union[httpx.Limits, None]
    def __init__(self, *, base_url: str | URL, max_retries: int = ..., timeout: float | Timeout | None = ..., limits: Limits | None = ..., custom_headers: Dict[str, str] | None = ..., custom_query: Dict[str, Any] | None = ...) -> None:
        ...
    
    @property
    def qs(self) -> Querystring:
        ...
    
    @property
    def auth_headers(self) -> dict[str, str]:
        ...
    
    @property
    def user_agent(self) -> str:
        ...
    
    def default_headers(self) -> Dict[str, str]:
        ...
    


class SyncAPIClient(BaseClient):
    _client: httpx.Client
    def __init__(self, *, base_url: str | URL, max_retries: int = ..., timeout: float | Timeout | None | NotGiven = ..., http_client: httpx.Client | None = ..., custom_headers: Dict[str, str] | None = ..., custom_query: Dict[str, object] | None = ...) -> None:
        ...
    
    def post(self, path: str, *, cast_to: Type[ResponseT], body: Dict | None = ..., options: ExtraRequestOptions = ..., files: RequestFiles | None = ..., stream: bool = ..., stream_cls: type[_StreamT] | None = ...) -> ResponseT | _StreamT:
        ...
    
    def get(self, path: str, *, cast_to: Type[ResponseT], params: list[tuple[str, str]] | None = ..., options: ExtraRequestOptions = ..., stream: bool = ..., stream_cls: type[_StreamT] | None = ...) -> ResponseT | _StreamT:
        ...
    
    def delete(self, path: str, *, cast_to: Type[ResponseT], params: list[tuple[str, str]] | None = ..., options: ExtraRequestOptions = ...) -> ResponseT:
        ...
    
    def post_without_retry(self, path: str, *, cast_to: Type[ResponseT], body: Dict | None = ..., options: ExtraRequestOptions = ..., files: RequestFiles | None = ..., stream: bool = ..., stream_cls: type[_StreamT] | None = ...) -> ResponseT | _StreamT:
        ...
    
    def get_api_list(self, path: str, *, model: Type[object], page: Type[SyncPageT], body: Body | None = ..., options: ExtraRequestOptions = ..., method: str = ...) -> AsyncPageT:
        ...
    
    def request(self, cast_to: Type[ResponseT], options: RequestOptions, remaining_retries: Optional[int] = ..., *, stream: bool = ..., stream_cls: type[_StreamT] | None = ...) -> ResponseT | _StreamT:
        ...
    
    def is_closed(self) -> bool:
        ...
    
    def close(self) -> None:
        """Close the underlying HTTPX client.

        The client will *not* be usable after this.
        """
        ...
    
    def __enter__(self: _T) -> _T:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


class _DefaultAsyncHttpxClient(httpx.AsyncClient):
    def __init__(self, **kwargs: Any) -> None:
        ...
    


if TYPE_CHECKING:
    DefaultAsyncHttpxClient = httpx.AsyncClient
else:
    ...
class AsyncHttpxClientWrapper(DefaultAsyncHttpxClient):
    def __del__(self) -> None:
        ...
    


class AsyncAPIClient(BaseClient):
    _client: httpx.AsyncClient
    def __init__(self, *, base_url: str | URL, max_retries: int = ..., timeout: float | Timeout | None | NotGiven = ..., http_client: httpx.AsyncClient | None = ..., custom_headers: Dict[str, str] | None = ..., custom_query: Dict[str, object] | None = ...) -> None:
        ...
    
    async def post(self, path: str, *, cast_to: Type[ResponseT], body: Dict | None = ..., options: ExtraRequestOptions = ..., files: RequestFiles | None = ..., stream: bool = ..., stream_cls: type[_AsyncStreamT] | None = ...) -> ResponseT | _AsyncStreamT:
        ...
    
    async def get(self, path: str, *, cast_to: Type[ResponseT], params: list[tuple[str, str]] | None = ..., options: ExtraRequestOptions = ..., stream: bool = ..., stream_cls: type[_AsyncStreamT] | None = ...) -> ResponseT | _AsyncStreamT:
        ...
    
    async def delete(self, path: str, *, cast_to: Type[ResponseT], params: list[tuple[str, str]] | None = ..., options: ExtraRequestOptions = ...) -> ResponseT:
        ...
    
    async def post_without_retry(self, path: str, *, cast_to: Type[ResponseT], body: Dict | None = ..., options: ExtraRequestOptions = ..., files: RequestFiles | None = ..., stream: bool = ..., stream_cls: type[_AsyncStreamT] | None = ...) -> ResponseT | _AsyncStreamT:
        ...
    
    async def get_api_list(self, path: str, *, model: Type[object], page: Type[AsyncPageT], body: Body | None = ..., options: ExtraRequestOptions = ..., method: str = ...) -> AsyncPageT:
        ...
    
    async def request(self, cast_to: Type[ResponseT], options: RequestOptions, remaining_retries: Optional[int] = ..., *, stream: bool = ..., stream_cls: type[_StreamT] | None = ...) -> ResponseT | _StreamT:
        ...
    
    def is_closed(self) -> bool:
        ...
    
    async def close(self) -> None:
        """Close the underlying HTTPX client.

        The client will *not* be usable after this.
        """
        ...
    
    async def __aenter__(self: _T) -> _T:
        ...
    
    async def __aexit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


class PageInfo:
    """Stores the necessary information to build the request to retrieve the next page.

    Either `url` or `params` must be set.
    """
    url: URL | NotGiven
    params: Query | NotGiven
    json: Body | NotGiven
    def __init__(self, *, url: URL | NotGiven = ..., json: Body | NotGiven = ..., params: Query | NotGiven = ...) -> None:
        ...
    
    @override
    def __repr__(self) -> str:
        ...
    


class BasePage(GenericModel, Generic[_T]):
    """
    Defines the core interface for pagination.

    Type Args:
        ModelT: The pydantic model that represents an item in the response.

    Methods:
        has_next_page(): Check if there is another page available
        next_page_info(): Get the necessary information to make a request for the next page
    """
    _options: RequestOptions = ...
    _model: Type[_T] = ...
    def has_next_page(self) -> bool:
        ...
    
    def next_page_info(self) -> Optional[PageInfo]:
        ...
    


class BaseSyncPage(BasePage[_T], Generic[_T]):
    _client: SyncAPIClient = ...
    def __iter__(self) -> Iterator[_T]:
        ...
    
    def iter_pages(self: SyncPageT) -> Iterator[SyncPageT]:
        ...
    
    def get_next_page(self: SyncPageT) -> SyncPageT:
        ...
    


class AsyncPaginator(Generic[_T, AsyncPageT]):
    def __init__(self, client: AsyncAPIClient, options: RequestOptions, page_cls: Type[AsyncPageT], model: Type[_T]) -> None:
        ...
    
    def __await__(self) -> Generator[Any, None, AsyncPageT]:
        ...
    
    async def __aiter__(self) -> AsyncIterator[_T]:
        ...
    


class BaseAsyncPage(BasePage[_T], Generic[_T]):
    _client: AsyncAPIClient = ...
    async def __aiter__(self) -> AsyncIterator[_T]:
        ...
    
    async def iter_pages(self: AsyncPageT) -> AsyncIterator[AsyncPageT]:
        ...
    
    async def get_next_page(self: AsyncPageT) -> AsyncPageT:
        ...
    


class ForceMultipartDict(Dict[str, None]):
    def __bool__(self) -> bool:
        ...
    


