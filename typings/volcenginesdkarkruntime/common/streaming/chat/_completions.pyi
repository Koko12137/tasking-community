"""
This type stub file was generated by pyright.
"""

from types import TracebackType
from typing import AsyncIterator, Awaitable, Callable, Generic, Iterable
from typing_extensions import Iterator, Self
from ._types import ParsedChatCompletionSnapshot, ParsedChoiceSnapshot
from ._events import ChatCompletionStreamEvent
from ...._types import NotGiven
from ..._parsing import ResponseFormatT
from ...._streaming import AsyncStream, Stream
from ....types.chat import ChatCompletionChunk, ChatCompletionToolParam, ParsedChatCompletion
from ....types.chat.chat_completion_chunk import Choice as ChoiceChunk
from ....types.chat.completion_create_params import ResponseFormat as ResponseFormatParam

class ChatCompletionStream(Generic[ResponseFormatT]):
    """Wrapper over the Chat Completions streaming API that adds helpful
    events such as `content.done`, supports automatically parsing
    responses & tool calls and accumulates a `ChatCompletion` object
    from each individual chunk.
    """
    def __init__(self, *, raw_stream: Stream[ChatCompletionChunk], response_format: type[ResponseFormatT] | ResponseFormatParam | NotGiven, input_tools: Iterable[ChatCompletionToolParam] | NotGiven) -> None:
        ...
    
    def __next__(self) -> ChatCompletionStreamEvent[ResponseFormatT]:
        ...
    
    def __iter__(self) -> Iterator[ChatCompletionStreamEvent[ResponseFormatT]]:
        ...
    
    def __enter__(self) -> Self:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    
    def close(self) -> None:
        """
        Close the response and release the connection.

        Automatically called if the response body is read to completion.
        """
        ...
    
    def get_final_completion(self) -> ParsedChatCompletion[ResponseFormatT]:
        """Waits until the stream has been read to completion and returns
        the accumulated `ParsedChatCompletion` object.

        If you passed a class type to `.stream()`, the `completion.choices[0].message.parsed`
        property will be the content deserialised into that class, if there was any content returned
        by the API.
        """
        ...
    
    def until_done(self) -> Self:
        """Blocks until the stream has been consumed."""
        ...
    
    @property
    def current_completion_snapshot(self) -> ParsedChatCompletionSnapshot:
        ...
    
    def __stream__(self) -> Iterator[ChatCompletionStreamEvent[ResponseFormatT]]:
        ...
    


class ChatCompletionStreamManager(Generic[ResponseFormatT]):
    """Context manager over a `ChatCompletionStream` that is returned by `.stream()`.

    This context manager ensures the response cannot be leaked if you don't read
    the stream to completion.

    Usage:
    ```py
    with client.beta.chat.completions.stream(...) as stream:
        for event in stream:
            ...
    ```
    """
    def __init__(self, api_request: Callable[[], Stream[ChatCompletionChunk]], *, response_format: type[ResponseFormatT] | ResponseFormatParam | NotGiven, input_tools: Iterable[ChatCompletionToolParam] | NotGiven) -> None:
        ...
    
    def __enter__(self) -> ChatCompletionStream[ResponseFormatT]:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


class AsyncChatCompletionStream(Generic[ResponseFormatT]):
    """Wrapper over the Chat Completions streaming API that adds helpful
    events such as `content.done`, supports automatically parsing
    responses & tool calls and accumulates a `ChatCompletion` object
    from each individual chunk.
    """
    def __init__(self, *, raw_stream: AsyncStream[ChatCompletionChunk], response_format: type[ResponseFormatT] | ResponseFormatParam | NotGiven, input_tools: Iterable[ChatCompletionToolParam] | NotGiven) -> None:
        ...
    
    async def __anext__(self) -> ChatCompletionStreamEvent[ResponseFormatT]:
        ...
    
    async def __aiter__(self) -> AsyncIterator[ChatCompletionStreamEvent[ResponseFormatT]]:
        ...
    
    async def __aenter__(self) -> Self:
        ...
    
    async def __aexit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    
    async def close(self) -> None:
        """
        Close the response and release the connection.

        Automatically called if the response body is read to completion.
        """
        ...
    
    async def get_final_completion(self) -> ParsedChatCompletion[ResponseFormatT]:
        """Waits until the stream has been read to completion and returns
        the accumulated `ParsedChatCompletion` object.

        If you passed a class type to `.stream()`, the `completion.choices[0].message.parsed`
        property will be the content deserialised into that class, if there was any content returned
        by the API.
        """
        ...
    
    async def until_done(self) -> Self:
        """Blocks until the stream has been consumed."""
        ...
    
    @property
    def current_completion_snapshot(self) -> ParsedChatCompletionSnapshot:
        ...
    
    async def __stream__(self) -> AsyncIterator[ChatCompletionStreamEvent[ResponseFormatT]]:
        ...
    


class AsyncChatCompletionStreamManager(Generic[ResponseFormatT]):
    """Context manager over a `AsyncChatCompletionStream` that is returned by `.stream()`.

    This context manager ensures the response cannot be leaked if you don't read
    the stream to completion.

    Usage:
    ```py
    async with client.beta.chat.completions.stream(...) as stream:
        for event in stream:
            ...
    ```
    """
    def __init__(self, api_request: Awaitable[AsyncStream[ChatCompletionChunk]], *, response_format: type[ResponseFormatT] | ResponseFormatParam | NotGiven, input_tools: Iterable[ChatCompletionToolParam] | NotGiven) -> None:
        ...
    
    async def __aenter__(self) -> AsyncChatCompletionStream[ResponseFormatT]:
        ...
    
    async def __aexit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


class ChatCompletionStreamState(Generic[ResponseFormatT]):
    def __init__(self, *, input_tools: Iterable[ChatCompletionToolParam] | NotGiven = ..., response_format: type[ResponseFormatT] | ResponseFormatParam | NotGiven = ...) -> None:
        ...
    
    def get_final_completion(self) -> ParsedChatCompletion[ResponseFormatT]:
        """Parse the final completion object.

        Note this does not provide any guarantees that the stream has actually finished, you must
        only call this method when the stream is finished.
        """
        ...
    
    @property
    def current_completion_snapshot(self) -> ParsedChatCompletionSnapshot:
        ...
    
    def handle_chunk(self, chunk: ChatCompletionChunk) -> Iterable[ChatCompletionStreamEvent[ResponseFormatT]]:
        """Accumulate a new chunk into the snapshot and returns an iterable of events to yield."""
        ...
    


class ChoiceEventState:
    def __init__(self, *, input_tools: list[ChatCompletionToolParam]) -> None:
        ...
    
    def get_done_events(self, *, choice_chunk: ChoiceChunk, choice_snapshot: ParsedChoiceSnapshot, response_format: type[ResponseFormatT] | ResponseFormatParam | NotGiven) -> list[ChatCompletionStreamEvent[ResponseFormatT]]:
        ...
    


