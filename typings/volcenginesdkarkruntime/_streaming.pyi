"""
This type stub file was generated by pyright.
"""

import httpx
from types import TracebackType
from typing import Any, AsyncIterator, Generic, Iterator, Optional, TYPE_CHECKING, TypeVar
from typing_extensions import Protocol, Self, TypeGuard, override, runtime_checkable
from ._client import Ark, AsyncArk

if TYPE_CHECKING:
    ...
_T = TypeVar("_T")
class Stream(Generic[_T]):
    """Provides the core interface to iterate over a synchronous stream response."""
    response: httpx.Response
    _decoder: SSEBytesDecoder
    def __init__(self, *, cast_to: type[_T], response: httpx.Response, client: Ark, iterator: Optional[Iterator[_T]] | None = ...) -> None:
        ...
    
    def __next__(self) -> _T:
        ...
    
    def __iter__(self) -> Iterator[_T]:
        ...
    
    def __stream__(self) -> Iterator[_T]:
        ...
    
    def __enter__(self) -> Self:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    
    def close(self) -> None:
        """
        Close the response and release the connection.

        Automatically called if the response body is read to completion.
        """
        ...
    


class AsyncStream(Generic[_T]):
    """Provides the core interface to iterate over an asynchronous stream response."""
    response: httpx.Response
    _decoder: SSEDecoder | SSEBytesDecoder
    def __init__(self, *, cast_to: type[_T], response: httpx.Response, client: AsyncArk, iterator: Optional[AsyncIterator[_T]] | None = ...) -> None:
        ...
    
    async def __anext__(self) -> _T:
        ...
    
    async def __aiter__(self) -> AsyncIterator[_T]:
        ...
    
    async def __stream__(self) -> AsyncIterator[_T]:
        ...
    
    async def __aenter__(self) -> Self:
        ...
    
    async def __aexit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    
    async def close(self) -> None:
        """
        Close the response and release the connection.

        Automatically called if the response body is read to completion.
        """
        ...
    


class ServerSentEvent:
    def __init__(self, *, event: str | None = ..., data: str | None = ..., id: str | None = ..., retry: int | None = ...) -> None:
        ...
    
    @property
    def event(self) -> str | None:
        ...
    
    @property
    def id(self) -> str | None:
        ...
    
    @property
    def retry(self) -> int | None:
        ...
    
    @property
    def data(self) -> str:
        ...
    
    def json(self) -> Any:
        ...
    
    @override
    def __repr__(self) -> str:
        ...
    


class SSEDecoder:
    _data: list[str]
    _event: str | None
    _retry: int | None
    _last_event_id: str | None
    def __init__(self) -> None:
        ...
    
    def iter_bytes(self, iterator: Iterator[bytes]) -> Iterator[ServerSentEvent]:
        """Given an iterator that yields raw binary data, iterate over it & yield every event encountered"""
        ...
    
    async def aiter_bytes(self, iterator: AsyncIterator[bytes]) -> AsyncIterator[ServerSentEvent]:
        """Given an iterator that yields raw binary data, iterate over it & yield every event encountered"""
        ...
    
    def decode(self, line: str) -> ServerSentEvent | None:
        ...
    


@runtime_checkable
class SSEBytesDecoder(Protocol):
    def iter_bytes(self, iterator: Iterator[bytes]) -> Iterator[ServerSentEvent]:
        """Given an iterator that yields raw binary data, iterate over it & yield every event encountered"""
        ...
    
    def aiter_bytes(self, iterator: AsyncIterator[bytes]) -> AsyncIterator[ServerSentEvent]:
        """Given an async iterator that yields raw binary data, iterate over it & yield every event encountered"""
        ...
    


def is_stream_class_type(typ: type) -> TypeGuard[type[Stream[object]] | type[AsyncStream[object]]]:
    """TypeGuard for determining whether or not the given type is a subclass of `Stream` / `AsyncStream`"""
    ...

def extract_stream_chunk_type(stream_cls: type, *, failure_message: str | None = ...) -> type:
    """Given a type like `Stream[T]`, returns the generic type variable `T`.

    This also handles the case where a concrete subclass is given, e.g.
    ```py
    class MyStream(Stream[bytes]):
        ...

    extract_stream_chunk_type(MyStream) -> bytes
    ```
    """
    ...

