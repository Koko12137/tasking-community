"""
This type stub file was generated by pyright.
"""

import sys
import typing_extensions
from typing import Any
from ._utils import lru_cache

def is_annotated_type(typ: type) -> bool:
    ...

def is_list_type(typ: type) -> bool:
    ...

def is_iterable_type(typ: type) -> bool:
    """If the given type is `typing.Iterable[T]`"""
    ...

def is_union_type(typ: type) -> bool:
    ...

def is_required_type(typ: type) -> bool:
    ...

def is_typevar(typ: type) -> bool:
    ...

_TYPE_ALIAS_TYPES: tuple[type[typing_extensions.TypeAliasType], ...] = ...
if sys.version_info >= (3, 12):
    _TYPE_ALIAS_TYPES = ...
def is_type_alias_type(tp: Any) -> bool:
    """Return whether the provided argument is an instance of `TypeAliasType`.

    example:
    ```python
    type Int = int
    is_type_alias_type(Int)
    # > True

    Str = TypeAliasType("Str", str)
    is_type_alias_type(Str)
    # > True
    ```
    """
    ...

@lru_cache(maxsize=8096)
def strip_annotated_type(typ: type) -> type:
    ...

def extract_type_arg(typ: type, index: int) -> type:
    ...

def extract_type_var_from_base(typ: type, *, generic_bases: tuple[type, ...], index: int, failure_message: str | None = ...) -> type:
    """Given a type like `Foo[T]`, returns the generic type variable `T`.

    This also handles the case where a concrete subclass is given, e.g.
    ```py
    class MyResponse(Foo[bytes]):
        ...

    extract_type_var(MyResponse, bases=(Foo,), index=0) -> bytes
    ```

    And where a generic subclass is given:
    ```py
    _T = TypeVar('_T')
    class MyResponse(Foo[_T]):
        ...

    extract_type_var(MyResponse[bytes], bases=(Foo,), index=0) -> bytes
    ```
    """
    ...

