"""
This type stub file was generated by pyright.
"""

from typing import Any, Mapping, TypeVar
from typing_extensions import Literal, override
from ._utils import lru_cache

_T = TypeVar("_T")
PropertyFormat = Literal["iso8601", "base64", "custom"]
class PropertyInfo:
    """Metadata class to be used in Annotated types to provide information about a given type.

    For example:

    class MyParams(TypedDict):
        account_holder_name: Annotated[str, PropertyInfo(alias='accountHolderName')]

    This means that {'account_holder_name': 'Robert'} will be transformed to {'accountHolderName': 'Robert'} before being sent to the API.
    """
    alias: str | None
    format: PropertyFormat | None
    format_template: str | None
    discriminator: str | None
    def __init__(self, *, alias: str | None = ..., format: PropertyFormat | None = ..., format_template: str | None = ..., discriminator: str | None = ...) -> None:
        ...
    
    @override
    def __repr__(self) -> str:
        ...
    


def maybe_transform(data: object, expected_type: object) -> Any | None:
    """Wrapper over `transform()` that allows `None` to be passed.

    See `transform()` for more details.
    """
    ...

def transform(data: _T, expected_type: object) -> _T:
    """Transform dictionaries based off of type information from the given type, for example:

    ```py
    class Params(TypedDict, total=False):
        card_id: Required[Annotated[str, PropertyInfo(alias="cardID")]]


    transformed = transform({"card_id": "<my card ID>"}, Params)
    # {'cardID': '<my card ID>'}
    ```

    Any keys / data that does not have type information given will be included as is.

    It should be noted that the transformations that this function does are not represented in the type system.
    """
    ...

async def async_maybe_transform(data: object, expected_type: object) -> Any | None:
    """Wrapper over `async_transform()` that allows `None` to be passed.

    See `async_transform()` for more details.
    """
    ...

async def async_transform(data: _T, expected_type: object) -> _T:
    """Transform dictionaries based off of type information from the given type, for example:

    ```py
    class Params(TypedDict, total=False):
        card_id: Required[Annotated[str, PropertyInfo(alias="cardID")]]


    transformed = transform({"card_id": "<my card ID>"}, Params)
    # {'cardID': '<my card ID>'}
    ```

    Any keys / data that does not have type information given will be included as is.

    It should be noted that the transformations that this function does are not represented in the type system.
    """
    ...

@lru_cache(maxsize=8096)
def get_type_hints(obj: Any, globalns: dict[str, Any] | None = ..., localns: Mapping[str, Any] | None = ..., include_extras: bool = ...) -> dict[str, Any]:
    ...

