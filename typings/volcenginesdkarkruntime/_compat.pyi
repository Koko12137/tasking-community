"""
This type stub file was generated by pyright.
"""

import pydantic
from typing import Any, Callable, Generic, TYPE_CHECKING, TypeVar, Union, overload
from datetime import date, datetime
from typing_extensions import Literal, Self
from pydantic.fields import FieldInfo
from ._types import IncEx

_T = TypeVar("_T")
_ModelT = TypeVar("_ModelT", bound=pydantic.BaseModel)
StrBytesIntFloat = Union[str, bytes, int, float]
PYDANTIC_V2 = ...
if TYPE_CHECKING:
    def parse_date(value: date | StrBytesIntFloat) -> date:
        ...
    
    def parse_datetime(value: Union[datetime, StrBytesIntFloat]) -> datetime:
        ...
    
    def get_args(t: type[Any]) -> tuple[Any, ...]:
        ...
    
    def is_union(tp: type[Any] | None) -> bool:
        ...
    
    def get_origin(t: type[Any]) -> type[Any] | None:
        ...
    
    def is_literal_type(type_: type[Any]) -> bool:
        ...
    
    def is_typeddict(type_: type[Any]) -> bool:
        ...
    
else:
    ...
if TYPE_CHECKING:
    ...
else:
    ...
def parse_obj(model: type[_ModelT], value: object) -> _ModelT:
    ...

def field_is_required(field: FieldInfo) -> bool:
    ...

def field_get_default(field: FieldInfo) -> Any:
    ...

def field_outer_type(field: FieldInfo) -> Any:
    ...

def get_model_config(model: type[pydantic.BaseModel]) -> Any:
    ...

def get_model_fields(model: type[pydantic.BaseModel]) -> dict[str, FieldInfo]:
    ...

def model_copy(model: _ModelT) -> _ModelT:
    ...

def model_json(model: pydantic.BaseModel, *, indent: int | None = ...) -> str:
    ...

def model_dump(model: pydantic.BaseModel, *, exclude: IncEx | None = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., warnings: bool = ..., mode: Literal["json", "python"] = ...) -> dict[str, Any]:
    ...

def model_parse(model: type[_ModelT], data: Any) -> _ModelT:
    ...

def model_parse_json(model: type[_ModelT], data: str | bytes) -> _ModelT:
    ...

def model_json_schema(model: type[_ModelT]) -> dict[str, Any]:
    ...

if TYPE_CHECKING:
    class GenericModel(pydantic.BaseModel):
        ...
    
    
else:
    ...
if TYPE_CHECKING:
    cached_property = property
    class typed_cached_property(Generic[_T]):
        func: Callable[[Any], _T]
        attrname: str | None
        def __init__(self, func: Callable[[Any], _T]) -> None:
            ...
        
        @overload
        def __get__(self, instance: None, owner: type[Any] | None = ...) -> Self:
            ...
        
        @overload
        def __get__(self, instance: object, owner: type[Any] | None = ...) -> _T:
            ...
        
        def __get__(self, instance: object, owner: type[Any] | None = ...) -> _T | Self:
            ...
        
        def __set_name__(self, owner: type[Any], name: str) -> None:
            ...
        
        def __set__(self, instance: object, value: _T) -> None:
            ...
        
    
    
else:
    ...
