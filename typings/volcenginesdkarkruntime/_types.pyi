"""
This type stub file was generated by pyright.
"""

import pydantic
from os import PathLike
from typing import Any, Callable, Dict, IO, List, Mapping, Optional, Sequence, TYPE_CHECKING, Tuple, Type, TypeVar, Union
from httpx import Response
from typing_extensions import Literal, Protocol, Set, TypeAlias, override, runtime_checkable
from ._models import BaseModel
from ._response import ArkAPIResponse, ArkAsyncAPIResponse

if TYPE_CHECKING:
    ...
ModelT = TypeVar("ModelT", bound=pydantic.BaseModel)
_T = TypeVar("_T")
ResponseT = TypeVar("ResponseT", bound=Union[object, str, None, "BaseModel", List[Any], Dict[str, Any], Response, "ArkAPIResponse[Any]", "ArkAsyncAPIResponse[Any]",])
if TYPE_CHECKING:
    Base64FileInput = Union[IO[bytes], PathLike[str]]
    FileContent = Union[IO[bytes], bytes, PathLike[str]]
else:
    ...
FileTypes = Union[FileContent, Tuple[Optional[str], FileContent], Tuple[Optional[str], FileContent, Optional[str]], Tuple[Optional[str], FileContent, Optional[str], Mapping[str, str]],]
RequestFiles = Union[Mapping[str, FileTypes], Sequence[Tuple[str, FileTypes]]]
HttpxFileContent = Union[IO[bytes], bytes]
HttpxFileTypes = Union[HttpxFileContent, Tuple[Optional[str], HttpxFileContent], Tuple[Optional[str], HttpxFileContent, Optional[str]], Tuple[Optional[str], HttpxFileContent, Optional[str], Mapping[str, str]],]
HttpxRequestFiles = Union[Mapping[str, HttpxFileTypes], Sequence[Tuple[str, HttpxFileTypes]]]
if TYPE_CHECKING:
    NoneType: Type[None]
    ...
else:
    ...
class NotGiven:
    """
    A sentinel singleton class used to distinguish omitted keyword arguments
    from those passed in with the value None (which may have different behavior).

    For example:

    ```py
    def get(timeout: Union[int, NotGiven, None] = NotGiven()) -> Response:
        ...


    get(timeout=1)  # 1s timeout
    get(timeout=None)  # No timeout
    get()  # Default timeout behavior, which may not be statically known at the method definition.
    ```
    """
    def __bool__(self) -> Literal[False]:
        ...
    
    @override
    def __repr__(self) -> str:
        ...
    


NotGivenOr = Union[_T, NotGiven]
NOT_GIVEN = ...
Headers = Dict[str, str]
Query = Dict[str, object]
Body = Dict[str, object]
AnyMapping = Mapping[str, object]
IncEx: TypeAlias = Union[Set[int], Set[str], Mapping[int, Union["IncEx", bool]], Mapping[str, Union["IncEx", bool]],]
PostParser = Callable[[Any], Any]
@runtime_checkable
class InheritsGeneric(Protocol):
    """Represents a type that has inherited from `Generic`

    The `__orig_bases__` property can be used to determine the resolved
    type variable for a given base class.
    """
    __orig_bases__: tuple[_GenericAlias]
    ...


class _GenericAlias(Protocol):
    __origin__: type[object]
    ...


_overload_registry = ...
def overload(func): # -> Callable[..., NoReturn]:
    """Decorator for overloaded functions/methods.

    In a stub file, place two or more stub definitions for the same
    function in a row, each decorated with @overload.

    For example::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...

    In a non-stub file (i.e. a regular .py file), do the same but
    follow it with an implementation.  The implementation should *not*
    be decorated with @overload::

        @overload
        def utf8(value: None) -> None: ...
        @overload
        def utf8(value: bytes) -> bytes: ...
        @overload
        def utf8(value: str) -> bytes: ...
        def utf8(value):
            ...  # implementation goes here

    The overloads for a function can be retrieved at runtime using the
    get_overloads() function.
    """
    ...

