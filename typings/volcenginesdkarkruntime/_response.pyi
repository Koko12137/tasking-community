"""
This type stub file was generated by pyright.
"""

import datetime
import logging
import httpx
from types import TracebackType
from typing import Any, AsyncIterator, Awaitable, Callable, Generic, Iterator, TYPE_CHECKING, TypeVar, Union, overload
from typing_extensions import ParamSpec, override
from ._exceptions import ArkError
from ._streaming import AsyncStream, Stream
from ._request_options import RequestOptions
from ._base_client import BaseClient

if TYPE_CHECKING:
    ...
P = ParamSpec("P")
R = TypeVar("R")
_T = TypeVar("_T")
_APIResponseT = TypeVar("_APIResponseT", bound="ArkAPIResponse[Any]")
_AsyncAPIResponseT = TypeVar("_AsyncAPIResponseT", bound="ArkAsyncAPIResponse[Any]")
_DefaultStreamT = TypeVar("_DefaultStreamT", bound=Union[Stream[Any], AsyncStream[Any]])
log: logging.Logger = ...
class BaseAPIResponse(Generic[R]):
    _cast_to: type[R]
    _client: BaseClient
    _parsed_by_type: dict[type[Any], Any]
    _is_sse_stream: bool
    _stream_cls: type[Stream[Any]] | type[AsyncStream[Any]] | None
    _request_id: str
    _options: RequestOptions
    http_response: httpx.Response
    def __init__(self, *, raw: httpx.Response, cast_to: type[R], client: BaseClient, stream: bool, stream_cls: type[Stream[Any]] | type[AsyncStream[Any]] | None, options: RequestOptions) -> None:
        ...
    
    @property
    def request_id(self) -> str:
        ...
    
    @property
    def headers(self) -> httpx.Headers:
        ...
    
    @property
    def http_request(self) -> httpx.Request:
        ...
    
    @property
    def status_code(self) -> int:
        ...
    
    @property
    def url(self) -> httpx.URL:
        ...
    
    @property
    def method(self) -> str:
        ...
    
    @property
    def http_version(self) -> str:
        ...
    
    @property
    def elapsed(self) -> datetime.timedelta:
        ...
    
    @property
    def is_closed(self) -> bool:
        ...
    
    @override
    def __repr__(self) -> str:
        ...
    


class ArkAPIResponse(BaseAPIResponse[R]):
    @property
    def request_id(self) -> str:
        ...
    
    def parse(self, *, to: type[_T] | None = ...) -> R | _T:
        """Returns the rich python representation of this response's data.

        For lower-level control, see `.read()`, `.json()`, `.iter_bytes()`.

        You can customise the type that the response is parsed into through
        the `to` argument, e.g.

        ```py
        class MyModel(BaseModel):
            foo: str


        obj = response.parse(to=MyModel)
        print(obj.foo)
        ```

        We support parsing:
          - `BaseModel`
          - `dict`
          - `list`
          - `Union`
          - `str`
          - `int`
          - `float`
          - `httpx.Response`
        """
        ...
    
    def read(self) -> bytes:
        ...
    
    def text(self) -> str:
        ...
    
    def json(self) -> object:
        ...
    
    def close(self) -> None:
        ...
    
    def iter_bytes(self, chunk_size: int | None = ...) -> Iterator[bytes]:
        ...
    
    def iter_text(self, chunk_size: int | None = ...) -> Iterator[str]:
        ...
    
    def iter_lines(self) -> Iterator[str]:
        ...
    


class ArkAsyncAPIResponse(BaseAPIResponse[R]):
    @property
    def request_id(self) -> str:
        ...
    
    @overload
    async def parse(self, *, to: type[_T]) -> _T:
        ...
    
    @overload
    async def parse(self) -> R:
        ...
    
    async def parse(self, *, to: type[_T] | None = ...) -> R | _T:
        """Returns the rich python representation of this response's data.

        For lower-level control, see `.read()`, `.json()`, `.iter_bytes()`.

        You can customise the type that the response is parsed into through
        the `to` argument, e.g.

        ```py
        class MyModel(BaseModel):
            foo: str


        obj = response.parse(to=MyModel)
        print(obj.foo)
        ```

        We support parsing:
          - `BaseModel`
          - `dict`
          - `list`
          - `Union`
          - `str`
          - `httpx.Response`
        """
        ...
    
    async def read(self) -> bytes:
        """Read and return the binary response content."""
        ...
    
    async def text(self) -> str:
        """Read and decode the response content into a string."""
        ...
    
    async def json(self) -> object:
        """Read and decode the JSON response content."""
        ...
    
    async def close(self) -> None:
        """Close the response and release the connection.

        Automatically called if the response body is read to completion.
        """
        ...
    
    async def iter_bytes(self, chunk_size: int | None = ...) -> AsyncIterator[bytes]:
        """
        A byte-iterator over the decoded response content.

        This automatically handles gzip, deflate and brotli encoded responses.
        """
        ...
    
    async def iter_text(self, chunk_size: int | None = ...) -> AsyncIterator[str]:
        """A str-iterator over the decoded response content
        that handles both gzip, deflate, etc but also detects the content's
        string encoding.
        """
        ...
    
    async def iter_lines(self) -> AsyncIterator[str]:
        """Like `iter_text()` but will only yield chunks for each line"""
        ...
    


class MissingStreamClassError(TypeError):
    def __init__(self) -> None:
        ...
    


class StreamAlreadyConsumed(ArkError):
    def __init__(self) -> None:
        ...
    


def to_raw_response_wrapper(func: Callable[P, R]) -> Callable[P, ArkAPIResponse[R]]:
    """Higher order function that takes one of our bound API methods and wraps it
    to support returning the raw `APIResponse` object directly.
    """
    ...

def async_to_raw_response_wrapper(func: Callable[P, Awaitable[R]]) -> Callable[P, Awaitable[ArkAsyncAPIResponse[R]]]:
    """Higher order function that takes one of our bound API methods and wraps it
    to support returning the raw `APIResponse` object directly.
    """
    ...

def to_streamed_response_wrapper(func: Callable[P, R]) -> Callable[P, ResponseContextManager[ArkAPIResponse[R]]]:
    """Higher order function that takes one of our bound API methods and wraps it
    to support streaming and returning the raw `APIResponse` object directly.
    """
    ...

def async_to_streamed_response_wrapper(func: Callable[P, Awaitable[R]]) -> Callable[P, AsyncResponseContextManager[ArkAsyncAPIResponse[R]]]:
    """Higher order function that takes one of our bound API methods and wraps it
    to support streaming and returning the raw `APIResponse` object directly.
    """
    ...

class ResponseContextManager(Generic[_APIResponseT]):
    """Context manager for ensuring that a request is not made
    until it is entered and that the response will always be closed
    when the context manager exits
    """
    def __init__(self, request_func: Callable[[], _APIResponseT]) -> None:
        ...
    
    def __enter__(self) -> _APIResponseT:
        ...
    
    def __exit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


class AsyncResponseContextManager(Generic[_AsyncAPIResponseT]):
    """Context manager for ensuring that a request is not made
    until it is entered and that the response will always be closed
    when the context manager exits
    """
    def __init__(self, api_request: Awaitable[_AsyncAPIResponseT]) -> None:
        ...
    
    async def __aenter__(self) -> _AsyncAPIResponseT:
        ...
    
    async def __aexit__(self, exc_type: type[BaseException] | None, exc: BaseException | None, exc_tb: TracebackType | None) -> None:
        ...
    


