"""
This type stub file was generated by pyright.
"""

import datetime
import logging
import httpx
from typing import Any, Generic, Iterator, TYPE_CHECKING, TypeVar, overload
from typing_extensions import ParamSpec, override
from ._errors import ZaiError
from ._streaming import StreamResponse
from ._http_client import HttpClient
from ._request_opt import FinalRequestOptions

if TYPE_CHECKING:
	...
P = ParamSpec('P')
R = TypeVar('R')
_T = TypeVar('_T')
_APIResponseT = TypeVar('_APIResponseT', bound='APIResponse[Any]')
log: logging.Logger = ...
class BaseAPIResponse(Generic[R]):
	_cast_type: type[R]
	_client: HttpClient
	_parsed_by_type: dict[type[Any], Any]
	_is_sse_stream: bool
	_stream_cls: type[StreamResponse[Any]]
	_options: FinalRequestOptions
	http_response: httpx.Response
	def __init__(self, *, raw: httpx.Response, cast_type: type[R], client: HttpClient, stream: bool, stream_cls: type[StreamResponse[Any]] | None = ..., options: FinalRequestOptions) -> None:
		...
	
	@property
	def headers(self) -> httpx.Headers:
		...
	
	@property
	def http_request(self) -> httpx.Request:
		"""Returns the httpx Request instance associated with the current response."""
		...
	
	@property
	def status_code(self) -> int:
		...
	
	@property
	def url(self) -> httpx.URL:
		"""Returns the URL for which the request was made."""
		...
	
	@property
	def method(self) -> str:
		...
	
	@property
	def http_version(self) -> str:
		...
	
	@property
	def elapsed(self) -> datetime.timedelta:
		"""The time taken for the complete request/response cycle to complete."""
		...
	
	@property
	def is_closed(self) -> bool:
		"""Whether or not the response body has been closed.

		If this is False then there is response data that has not been read yet.
		You must either fully consume the response body or call `.close()`
		before discarding the response to prevent resource leaks.
		"""
		...
	
	@override
	def __repr__(self) -> str:
		...
	


class APIResponse(BaseAPIResponse[R]):
	@property
	def request_id(self) -> str | None:
		...
	
	@overload
	def parse(self, *, to: type[_T]) -> _T:
		...
	
	@overload
	def parse(self) -> R:
		...
	
	def parse(self, *, to: type[_T] | None = ...) -> R | _T:
		"""Returns the rich python representation of this response's data.

		For lower-level control, see `.read()`, `.json()`, `.iter_bytes()`.

		You can customise the type that the response is parsed into through
		the `to` argument, e.g.

		```py
		from openai import BaseModel


		class MyModel(BaseModel):
		    foo: str


		obj = response.parse(to=MyModel)
		print(obj.foo)
		```

		We support parsing:
		  - `BaseModel`
		  - `dict`
		  - `list`
		  - `Union`
		  - `str`
		  - `int`
		  - `float`
		  - `httpx.Response`
		"""
		...
	
	def read(self) -> bytes:
		"""Read and return the binary response content."""
		...
	
	def text(self) -> str:
		"""Read and decode the response content into a string."""
		...
	
	def json(self) -> object:
		"""Read and decode the JSON response content."""
		...
	
	def close(self) -> None:
		"""Close the response and release the connection.

		Automatically called if the response body is read to completion.
		"""
		...
	
	def iter_bytes(self, chunk_size: int | None = ...) -> Iterator[bytes]:
		"""
		A byte-iterator over the decoded response content.

		This automatically handles gzip, deflate and brotli encoded responses.
		"""
		...
	
	def iter_text(self, chunk_size: int | None = ...) -> Iterator[str]:
		"""A str-iterator over the decoded response content
		that handles both gzip, deflate, etc but also detects the content's
		string encoding.
		"""
		...
	
	def iter_lines(self) -> Iterator[str]:
		"""Like `iter_text()` but will only yield chunks for each line"""
		...
	


class MissingStreamClassError(TypeError):
	def __init__(self) -> None:
		...
	


class StreamAlreadyConsumed(ZaiError):
	"""
	Attempted to read or stream content, but the content has already
	been streamed.

	This can happen if you use a method like `.iter_lines()` and then attempt
	to read th entire response body afterwards, e.g.

	```py
	response = await client.post(...)
	async for line in response.iter_lines():
	    ...  # do something with `line`

	content = await response.read()
	# ^ error
	```

	If you want this behaviour you'll need to either manually accumulate the response
	content or call `await response.read()` before iterating over the stream.
	"""
	def __init__(self) -> None:
		...
	


def extract_response_type(typ: type[BaseAPIResponse[Any]]) -> type:
	"""Given a type like `APIResponse[T]`, returns the generic type variable `T`.

	This also handles the case where a concrete subclass is given, e.g.
	```py
	class MyResponse(APIResponse[bytes]):
	    ...

	extract_response_type(MyResponse) -> bytes
	```
	"""
	...

