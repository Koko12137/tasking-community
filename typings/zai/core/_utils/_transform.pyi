"""
This type stub file was generated by pyright.
"""

import io
from typing import Any, TYPE_CHECKING, TypeVar, Union
from typing_extensions import Literal, TypeGuard, override
from os import PathLike

_T = TypeVar('_T')
if TYPE_CHECKING:
	Base64FileInput = Union[io.IOBase, PathLike[str]]
else:
	...
def is_base64_file_input(obj: object) -> TypeGuard[Base64FileInput]:
	"""Check if object is a valid base64 file input."""
	...

PropertyFormat = Literal['iso8601', 'base64', 'custom']
class PropertyInfo:
	"""Metadata class to be used in Annotated types to provide information about a given type.

	For example:

	class MyParams(TypedDict):
	    account_holder_name: Annotated[str, PropertyInfo(alias='accountHolderName')]

	This means that {'account_holder_name': 'Robert'} will be transformed to
	{'accountHolderName': 'Robert'} before being sent to the API.
	"""
	alias: str | None
	format: PropertyFormat | None
	format_template: str | None
	discriminator: str | None
	def __init__(self, *, alias: str | None = ..., format: PropertyFormat | None = ..., format_template: str | None = ..., discriminator: str | None = ...) -> None:
		...
	
	@override
	def __repr__(self) -> str:
		...
	


def maybe_transform(data: object, expected_type: object) -> Any | None:
	"""Wrapper over `transform()` that allows `None` to be passed.

	See `transform()` for more details.
	"""
	...

def transform(data: _T, expected_type: object) -> _T:
	"""Transform dictionaries based off of type information from the given type, for example:

	```py
	class Params(TypedDict, total=False):
	    card_id: Required[Annotated[str, PropertyInfo(alias='cardID')]]


	transformed = transform({'card_id': '<my card ID>'}, Params)
	# {'cardID': '<my card ID>'}
	```

	Any keys / data that does not have type information given will be included as is.

	It should be noted that the transformations that this function does are not represented in the type system.
	"""
	...

async def async_maybe_transform(data: object, expected_type: object) -> Any | None:
	"""Wrapper over `async_transform()` that allows `None` to be passed.

	See `async_transform()` for more details.
	"""
	...

async def async_transform(data: _T, expected_type: object) -> _T:
	"""Transform dictionaries based off of type information from the given type, for example:

	```py
	class Params(TypedDict, total=False):
	    card_id: Required[Annotated[str, PropertyInfo(alias='cardID')]]


	transformed = transform({'card_id': '<my card ID>'}, Params)
	# {'cardID': '<my card ID>'}
	```

	Any keys / data that does not have type information given will be included as is.

	It should be noted that the transformations that this function does are not represented in the type system.
	"""
	...

