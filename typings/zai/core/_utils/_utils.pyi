"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Iterable, List, Mapping, Sequence, Tuple, TypeVar, Union, overload
from typing_extensions import TypeGuard
from .._base_type import FileTypes, HeadersLike, NotGiven, NotGivenOr

def remove_notgiven_indict(obj): # -> dict[Any, Any]:
	...

_T = TypeVar('_T')
_TupleT = TypeVar('_TupleT', bound=Tuple[object, ...])
_MappingT = TypeVar('_MappingT', bound=Mapping[str, object])
_SequenceT = TypeVar('_SequenceT', bound=Sequence[object])
CallableT = TypeVar('CallableT', bound=Callable[..., Any])
def flatten(t: Iterable[Iterable[_T]]) -> list[_T]:
	...

def extract_files(query: Mapping[str, object], *, paths: Sequence[Sequence[str]]) -> list[tuple[str, FileTypes]]:
	"""Recursively extract files from the given dictionary based on specified paths.

	A path may look like this ['foo', 'files', '<array>', 'data'].

	Note: this mutates the given dictionary.
	"""
	...

def is_given(obj: NotGivenOr[_T]) -> TypeGuard[_T]:
	...

def is_tuple(obj: object) -> TypeGuard[tuple[object, ...]]:
	...

def is_tuple_t(obj: _TupleT | object) -> TypeGuard[_TupleT]:
	...

def is_sequence(obj: object) -> TypeGuard[Sequence[object]]:
	...

def is_sequence_t(obj: _SequenceT | object) -> TypeGuard[_SequenceT]:
	...

def is_mapping(obj: object) -> TypeGuard[Mapping[str, object]]:
	...

def is_mapping_t(obj: _MappingT | object) -> TypeGuard[_MappingT]:
	...

def is_dict(obj: object) -> TypeGuard[dict[object, object]]:
	...

def is_list(obj: object) -> TypeGuard[list[object]]:
	...

def is_iterable(obj: object) -> TypeGuard[Iterable[object]]:
	...

def deepcopy_minimal(item: _T) -> _T:
	"""Minimal reimplementation of copy.deepcopy() that will only copy certain object types:

	- mappings, e.g. `dict`
	- list

	This is done for performance reasons.
	"""
	...

def human_join(seq: Sequence[str], *, delim: str = ..., final: str = ...) -> str:
	...

def quote(string: str) -> str:
	"""Add single quotation marks around the given string. Does *not* do any escaping."""
	...

def required_args(*variants: Sequence[str]) -> Callable[[CallableT], CallableT]:
	"""Decorator to enforce a given set of arguments or variants of arguments are passed to the decorated function.

	Useful for enforcing runtime validation of overloaded functions.

	Example usage:
	```py
	@overload
	def foo(*, a: str) -> str: ...


	@overload
	def foo(*, b: bool) -> str: ...


	# This enforces the same constraints that a static type checker would
	# i.e. that either a or b must be passed to the function
	@required_args(['a'], ['b'])
	def foo(*, a: str | None = None, b: bool | None = None) -> str: ...
	```
	"""
	...

_K = TypeVar('_K')
_V = TypeVar('_V')
@overload
def strip_not_given(obj: None) -> None:
	...

@overload
def strip_not_given(obj: Mapping[_K, _V | NotGiven]) -> dict[_K, _V]:
	...

@overload
def strip_not_given(obj: object) -> object:
	...

def strip_not_given(obj: object | None) -> object:
	"""Remove all top-level keys where their values are instances of `NotGiven`"""
	...

def coerce_integer(val: str) -> int:
	...

def coerce_float(val: str) -> float:
	...

def coerce_boolean(val: str) -> bool:
	...

def maybe_coerce_integer(val: str | None) -> int | None:
	...

def maybe_coerce_float(val: str | None) -> float | None:
	...

def maybe_coerce_boolean(val: str | None) -> bool | None:
	...

def removeprefix(string: str, prefix: str) -> str:
	"""Remove a prefix from a string.

	Backport of `str.removeprefix` for Python < 3.9
	"""
	...

def removesuffix(string: str, suffix: str) -> str:
	"""Remove a suffix from a string.

	Backport of `str.removesuffix` for Python < 3.9
	"""
	...

def file_from_path(path: str) -> FileTypes:
	...

def get_required_header(headers: HeadersLike, header: str) -> str:
	...

def get_async_library() -> str:
	...

def drop_prefix_image_data(content: Union[str, List[dict]]) -> Union[str, List[dict]]:
	"""
	Drop the prefix 'data:image/' from image data.

	Args:
	  content: Content to process

	Returns:
	  Processed content
	"""
	...

