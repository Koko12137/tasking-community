"""
This type stub file was generated by pyright.
"""

import logging
import httpx
from typing import Any, Generic, Iterator, Literal, Mapping, Optional, TYPE_CHECKING, Type, TypeVar, Union, overload
from httpx import Timeout, URL
from ._base_models import GenericModel
from ._base_type import Body, Headers, NotGiven, PostParser, Query, RequestFiles, ResponseT
from ._request_opt import FinalRequestOptions, UserRequestInput
from ._streaming import StreamResponse

log: logging.Logger = ...
SyncPageT = TypeVar('SyncPageT', bound='BaseSyncPage[Any]')
_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
if TYPE_CHECKING:
	...
else:
	...
headers = ...
class PageInfo:
	"""Stores the necessary information to build the request to retrieve the next page.

	Either `url` or `params` must be set.
	"""
	url: URL | NotGiven
	params: Query | NotGiven
	@overload
	def __init__(self, *, url: URL) -> None:
		...
	
	@overload
	def __init__(self, *, params: Query) -> None:
		...
	
	def __init__(self, *, url: URL | NotGiven = ..., params: Query | NotGiven = ...) -> None:
		...
	


class BasePage(GenericModel, Generic[_T]):
	"""
	Defines the core interface for pagination.

	Type Args:
	    ModelT: The pydantic model that represents an item in the response.

	Methods:
	    has_next_page(): Check if there is another page available
	    next_page_info(): Get the necessary information to make a request for the next page
	"""
	_options: FinalRequestOptions = ...
	_model: Type[_T] = ...
	def has_next_page(self) -> bool:
		...
	
	def next_page_info(self) -> Optional[PageInfo]:
		...
	


class BaseSyncPage(BasePage[_T], Generic[_T]):
	_client: HttpClient = ...
	def __iter__(self) -> Iterator[_T]:
		...
	
	def iter_pages(self: SyncPageT) -> Iterator[SyncPageT]:
		...
	
	def get_next_page(self: SyncPageT) -> SyncPageT:
		...
	


class HttpClient:
	_client: httpx.Client
	_version: str
	_base_url: URL
	max_retries: int
	timeout: Union[float, Timeout, None]
	_limits: httpx.Limits
	_has_custom_http_client: bool
	_default_stream_cls: Type[StreamResponse[Any]] | None = ...
	_strict_response_validation: bool
	def __init__(self, *, version: str, base_url: URL, _strict_response_validation: bool, max_retries: int = ..., timeout: Union[float, Timeout, None], limits: httpx.Limits | None = ..., custom_httpx_client: httpx.Client | None = ..., custom_headers: Mapping[str, str] | None = ...) -> None:
		...
	
	@property
	def custom_auth(self) -> httpx.Auth | None:
		...
	
	@property
	def auth_headers(self): # -> dict[Any, Any]:
		...
	
	def is_closed(self) -> bool:
		...
	
	def close(self): # -> None:
		...
	
	def __enter__(self): # -> Self:
		...
	
	def __exit__(self, exc_type, exc_val, exc_tb): # -> None:
		...
	
	def request(self, cast_type: Type[ResponseT], options: FinalRequestOptions, remaining_retries: Optional[int] = ..., *, stream: bool = ..., stream_cls: Type[StreamResponse] | None = ...) -> ResponseT | StreamResponse:
		...
	
	@overload
	def get(self, path: str, *, cast_type: Type[ResponseT], options: UserRequestInput = ..., stream: Literal[False] = ...) -> ResponseT:
		...
	
	@overload
	def get(self, path: str, *, cast_type: Type[ResponseT], options: UserRequestInput = ..., stream: Literal[True], stream_cls: Type[StreamResponse]) -> StreamResponse:
		...
	
	@overload
	def get(self, path: str, *, cast_type: Type[ResponseT], options: UserRequestInput = ..., stream: bool, stream_cls: Type[StreamResponse] | None = ...) -> ResponseT | StreamResponse:
		...
	
	def get(self, path: str, *, cast_type: Type[ResponseT], options: UserRequestInput = ..., stream: bool = ..., stream_cls: Type[StreamResponse] | None = ...) -> ResponseT:
		...
	
	@overload
	def post(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ..., files: RequestFiles | None = ..., stream: Literal[False] = ...) -> ResponseT:
		...
	
	@overload
	def post(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ..., files: RequestFiles | None = ..., stream: Literal[True], stream_cls: Type[StreamResponse]) -> StreamResponse:
		...
	
	@overload
	def post(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ..., files: RequestFiles | None = ..., stream: bool, stream_cls: Type[StreamResponse] | None = ...) -> ResponseT | StreamResponse:
		...
	
	def post(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ..., files: RequestFiles | None = ..., stream: bool = ..., stream_cls: Type[StreamResponse[Any]] | None = ...) -> ResponseT | StreamResponse:
		...
	
	def patch(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ...) -> ResponseT:
		...
	
	def put(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ..., files: RequestFiles | None = ...) -> ResponseT | StreamResponse:
		...
	
	def delete(self, path: str, *, cast_type: Type[ResponseT], body: Body | None = ..., options: UserRequestInput = ...) -> ResponseT | StreamResponse:
		...
	
	def get_api_list(self, path: str, *, model: Type[object], page: Type[SyncPageT], body: Body | None = ..., options: UserRequestInput = ..., method: str = ...) -> SyncPageT:
		...
	


def make_request_options(*, query: Query | None = ..., extra_headers: Headers | None = ..., extra_query: Query | None = ..., extra_body: Body | None = ..., timeout: float | httpx.Timeout | None | NotGiven = ..., post_parser: PostParser | NotGiven = ...) -> UserRequestInput:
	"""Create a dict of type RequestOptions without keys of NotGiven values."""
	...

