"""
This type stub file was generated by pyright.
"""

import pydantic
from typing import Any, Callable, TYPE_CHECKING, Type, TypeVar
from typing_extensions import ClassVar, Literal, ParamSpec, Protocol, TypeGuard, override, runtime_checkable
from ._base_compat import ConfigDict, PYDANTIC_V2
from ._base_type import IncEx, ModelT

if TYPE_CHECKING:
	...
__all__ = ['BaseModel', 'GenericModel']
_BaseModelT = TypeVar('_BaseModelT', bound='BaseModel')
_T = TypeVar('_T')
P = ParamSpec('P')
@runtime_checkable
class _ConfigProtocol(Protocol):
	allow_population_by_field_name: bool
	...


class BaseModel(pydantic.BaseModel):
	if PYDANTIC_V2:
		model_config: ClassVar[ConfigDict] = ...
	else:
		@property
		@override
		def model_fields_set(self) -> set[str]:
			...
		
		class Config(pydantic.BaseConfig):
			extra: Any = ...
		
		
	def to_dict(self, *, mode: Literal['json', 'python'] = ..., use_api_names: bool = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., warnings: bool = ...) -> dict[str, object]:
		"""Recursively generate a dictionary representation of the model,
		optionally specifying which fields to include or exclude.

		By default, fields that were not set by the API will not be included,
		and keys will match the API response, *not* the property names from the model.

		For example, if the API responds with `"fooBar": true` but we've defined a `foo_bar: bool` property,
		the output will use the `"fooBar"` key (unless `use_api_names=False` is passed).

		Args:
		    mode:
		        If mode is 'json', the dictionary will only contain JSON serializable types.
		        e.g. `datetime` will be turned into a string, `"2024-3-22T18:11:19.117000Z"`.
		        If mode is 'python', the dictionary may contain any Python objects.
		        e.g. `datetime(2024, 3, 22)`

		    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.
		    exclude_unset: Whether to exclude fields that have not been explicitly set.
		    exclude_defaults: Whether to exclude fields that are set to their default value from the output.
		    exclude_none: Whether to exclude fields that have a value of `None` from the output.
		    warnings: Whether to log warnings when invalid fields are encountered.
		        This is only supported in Pydantic v2.
		"""
		...
	
	def to_json(self, *, indent: int | None = ..., use_api_names: bool = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., warnings: bool = ...) -> str:
		"""Generates a JSON string representing this model as it would be received
		from or sent to the API (but with indentation).

		By default, fields that were not set by the API will not be included,
		and keys will match the API response, *not* the property names from the model.

		For example, if the API responds with `"fooBar": true` but we've defined a `foo_bar: bool` property,
		the output will use the `"fooBar"` key (unless `use_api_names=False` is passed).

		Args:
		    indent: Indentation to use in the JSON output. If `None` is passed,
		        the output will be compact. Defaults to `2`
		    use_api_names: Whether to use the key that the API responded with or the property name. Defaults to `True`.
		    exclude_unset: Whether to exclude fields that have not been explicitly set.
		    exclude_defaults: Whether to exclude fields that have the default value.
		    exclude_none: Whether to exclude fields that have a value of `None`.
		    warnings: Whether to show any warnings that occurred during serialization.
		        This is only supported in Pydantic v2.
		"""
		...
	
	def get(self, key: str, default: Any = ...) -> Any:
		"""Get the value of an attribute by name, with an optional default value.
		
		This method allows you to access model attributes by their string name,
		similar to how dict.get() works.
		
		Args:
		    key: The name of the attribute to get
		    default: The value to return if the attribute doesn't exist or is None.
		        Defaults to None.
		        
		Returns:
		    The value of the attribute if it exists, otherwise the default value.
		    
		Examples:
		    >>> model = MyModel(name="test", age=25)
		    >>> model.get("name")  # Returns "test"
		    >>> model.get("nonexistent")  # Returns None
		    >>> model.get("nonexistent", "default")  # Returns "default"
		"""
		...
	
	def __json__(self) -> dict[str, Any]:
		"""Custom JSON serialization method.
		
		This method is called by JSON encoders that support the __json__ protocol,
		making BaseModel objects directly serializable without requiring model_dump().
		
		Returns:
		    A dictionary representation of the model suitable for JSON serialization.
		"""
		...
	
	def __reduce_ex__(self, protocol): # -> tuple[Callable[..., Self], tuple[dict[str, Any]]]:
		"""Support for pickle serialization by returning the dict representation."""
		...
	
	def __iter__(self): # -> Iterator[tuple[str, Any]]:
		"""Make BaseModel iterable to support dict() conversion."""
		...
	
	def keys(self): # -> dict_keys[str, Any]:
		"""Return keys for dict-like interface."""
		...
	
	def values(self): # -> dict_values[str, Any]:
		"""Return values for dict-like interface."""
		...
	
	def items(self): # -> dict_items[str, Any]:
		"""Return items for dict-like interface."""
		...
	
	@override
	def __str__(self) -> str:
		...
	
	@classmethod
	@override
	def construct(cls: Type[ModelT], _fields_set: set[str] | None = ..., **values: object) -> ModelT:
		...
	
	if not TYPE_CHECKING:
		...
	if not PYDANTIC_V2:
		@override
		def model_dump(self, *, mode: Literal['json', 'python'] | str = ..., include: IncEx = ..., exclude: IncEx = ..., by_alias: bool = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., round_trip: bool = ..., warnings: bool | Literal['none', 'warn', 'error'] = ..., context: dict[str, Any] | None = ..., serialize_as_any: bool = ...) -> dict[str, Any]:
			"""Usage docs: https://docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump

			Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

			Args:
			    mode: The mode in which `to_python` should run.
			        If mode is 'json', the dictionary will only contain JSON serializable types.
			        If mode is 'python', the dictionary may contain any Python objects.
			    include: A list of fields to include in the output.
			    exclude: A list of fields to exclude from the output.
			    by_alias: Whether to use the field's alias in the dictionary key if defined.
			    exclude_unset: Whether to exclude fields that are unset or None from the output.
			    exclude_defaults: Whether to exclude fields that are set to their default value from the output.
			    exclude_none: Whether to exclude fields that have a value of `None` from the output.
			    round_trip: Whether to enable serialization and deserialization round-trip support.
			    warnings: Whether to log warnings when invalid fields are encountered.

			Returns:
			    A dictionary representation of the model.
			"""
			...
		
		@override
		def model_dump_json(self, *, indent: int | None = ..., include: IncEx = ..., exclude: IncEx = ..., by_alias: bool = ..., exclude_unset: bool = ..., exclude_defaults: bool = ..., exclude_none: bool = ..., round_trip: bool = ..., warnings: bool | Literal['none', 'warn', 'error'] = ..., context: dict[str, Any] | None = ..., serialize_as_any: bool = ...) -> str:
			"""Usage docs: https://docs.pydantic.dev/2.4/concepts/serialization/#modelmodel_dump_json

			Generates a JSON representation of the model using Pydantic's `to_json` method.

			Args:
			    indent: Indentation to use in the JSON output. If None is passed, the output will be compact.
			    include: Field(s) to include in the JSON output. Can take either a string or set of strings.
			    exclude: Field(s) to exclude from the JSON output. Can take either a string or set of strings.
			    by_alias: Whether to serialize using field aliases.
			    exclude_unset: Whether to exclude fields that have not been explicitly set.
			    exclude_defaults: Whether to exclude fields that have the default value.
			    exclude_none: Whether to exclude fields that have a value of `None`.
			    round_trip: Whether to use serialization/deserialization between JSON and class instance.
			    warnings: Whether to show any warnings that occurred during serialization.

			Returns:
			    A JSON string representation of the model.
			"""
			...
		


def is_basemodel(type_: type) -> bool:
	"""Returns whether or not the given type is either a `BaseModel` or a union of `BaseModel`"""
	...

def is_basemodel_type(type_: type) -> TypeGuard[type[BaseModel] | type[GenericModel]]:
	...

def build(base_model_cls: Callable[P, _BaseModelT], *args: P.args, **kwargs: P.kwargs) -> _BaseModelT:
	"""Construct a BaseModel class without validation.

	This is useful for cases where you need to instantiate a `BaseModel`
	from an API response as this provides type-safe params which isn't supported
	by helpers like `construct_type()`.

	```py
	build(MyModel, my_field_a='foo', my_field_b=123)
	```
	"""
	...

def construct_type_unchecked(*, value: object, type_: type[_T]) -> _T:
	"""Loose coercion to the expected type with construction of nested values.

	Note: the returned value from this function is not guaranteed to match the
	given type.
	"""
	...

def construct_type(*, value: object, type_: type) -> object:
	"""Loose coercion to the expected type with construction of nested values.

	If the given value does not match the expected type then it is returned as-is.
	"""
	...

@runtime_checkable
class CachedDiscriminatorType(Protocol):
	__discriminator__: DiscriminatorDetails
	...


class DiscriminatorDetails:
	field_name: str
	field_alias_from: str | None
	mapping: dict[str, type]
	def __init__(self, *, mapping: dict[str, type], discriminator_field: str, discriminator_alias: str | None) -> None:
		...
	


def validate_type(*, type_: type[_T], value: object) -> _T:
	"""Strict validation that the given value matches the expected type"""
	...

if TYPE_CHECKING:
	GenericModel = BaseModel
else:
	...
if PYDANTIC_V2:
	...
else:
	...
